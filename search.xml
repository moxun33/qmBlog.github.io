<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React应用优化]]></title>
    <url>%2F2018%2F11%2F21%2FReact%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[随着功能不断增加，不断迭代更新，React应用会越来越臃肿了，性能也将随之下降。本文从打包和运行两个方面着手，谈谈React应用改如何优化。 一、webpack打包优化1、缓存node_moduels我公司的项目每次上线部署的时候，虽然说都要要Jenkins上，但项目越来越多，每个项目部署占用时间都很长，导致每次部署完一个环境的所有项目耗费很多时间。 如果将同一项目的node_mudules在每次打包完毕后缓存起来，下次打包前先判断是否与上次node_moduels相同。若相同，则直接使用上次缓存的node_modules,否则才重新安装依赖包。 那该如何实现上面所说的逻辑？ 检查packages.json的 md5； 打包完成后以该次packages.json的md5值作为文件名，压缩node_modules并缓存到指定位置； 下次打包前，同样先检查当次packages.json的 md5，若相同直接使用上次的node_moduels; 具体的SHELL如下： 12345678910111213141516171819202122232425262728293031323334#!/bin/bashPKG_SUM=$(md5sum package.json | cut -d\ -f 1)NPM_TARBALL_CACHE=$&#123;HOME&#125;/.cache/ReactCache/npmtarball/reactSPANPM_TARBALL=node_modules-$&#123;PKG_SUM&#125;.tgzNPM_TARBALL_MD5SUM=$&#123;NPM_TARBALL&#125;.md5sum [ ! -e $&#123;NPM_TARBALL_CACHE&#125; ] &amp;&amp; mkdir -p $&#123;NPM_TARBALL_CACHE&#125; TARBALL=$&#123;NPM_TARBALL_CACHE&#125;/$&#123;NPM_TARBALL&#125; TARBALLMD5SUM=$&#123;NPM_TARBALL_CACHE&#125;/$&#123;NPM_TARBALL_MD5SUM&#125; echo "checking node modules "$&#123;TARBALL&#125; if [ ! -f $&#123;TARBALL&#125; ];then echo "package.json has some changes, reinstall node modules" rm -rf $&#123;NPM_TARBALL_CACHE&#125;/* yarn echo "yarn success" if [ -d node_modules ];then echo "tar and caching..." tar zcf $&#123;TARBALL&#125; node_modules || return 1 md5sum $&#123;TARBALL&#125; &gt; $&#123;TARBALLMD5SUM&#125; echo "checking current MD5." md5sum -c $&#123;TARBALLMD5SUM&#125; || rm -f $&#123;TARBALL&#125; $&#123;TARBALLMD5SUM&#125; echo "install completed, cached" fi else echo "package.json has no changes, clone previous node modules" if [ -d node_modules ];then echo "node_modules dir existed "$&#123;TARBALL&#125; else echo "unpacking..." $&#123;TARBALL&#125; tar xzf $&#123;TARBALL&#125; fi fichmod -R a+rwx node_modules 2、加速代码压缩webpack提供的UglifyJS插件由于采用单线程压缩，速度很慢 ,webpack-parallel-uglify-plugin插件可以并行运行UglifyJS插件，这可以有效减少构建时间，当然，该插件应用于生产环境而非开发环境，配置如下： 12345678910111213var ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');new ParallelUglifyPlugin(&#123; cacheDir: '.cache/', uglifyJS:&#123; output: &#123; comments: false &#125;, compress: &#123; warnings: false &#125; &#125; &#125;) 3、HappyPack加速构建happypack的原理是让loader可以多进程去处理文件，原理如图示： 目前项目中基本只对js和less文件使用HappyPack加速,具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637var HappyPack = require('happypack'), os = require('os'), happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);modules: &#123; loaders: [ &#123; test: /\.js|jsx$/, loader: 'HappyPack/loader?id=jsHappy', exclude: /node_modules/ &#125; ]&#125;plugins: [ new HappyPack(&#123; id: 'jsHappy', cache: true, threadPool: happyThreadPool, loaders: [&#123; path: 'babel', query: &#123; cacheDirectory: '.webpack_cache', presets: [ 'es2015', 'react' ] &#125; &#125;] &#125;), //如果有单独提取css文件的话 new HappyPack(&#123; id: 'lessHappy', loaders: ['style','css','less'] &#125;) ] 4、DLL&amp; DllReference针对第三方NPM包，这些包我们并不会修改它，但仍然每次都要在build的过程消耗构建性能，我们可以通过DllPlugin来前置这些包的构建.我们使用dllplugin把第三方的NPM包生成一个名为 manifest.json 的文件，这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。在文件中引入该dll文件即可。其原理是通过引用 dll 的 manifest 文件来把依赖的名称映射到模块的 id 上，之后再在需要的时候通过内置的 __webpack_require__ 函数来 require 他们。 但对于antd这样的按需加载UI库，不能放在dll中，否则会全部打包进去，按需加载就无效了。 具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576///dll.entry.js 定义dll的入口const DLL_ENTRY = &#123; react: ['react', 'react-dom', 'react-router-dom', 'prop-types'], echarts: ['echarts'], vendor: ['mobx', 'mobx-react', 'axios'], db: ['dexie'],&#125;;// 定义需要dll 分离的包名const DLL_CHUNKS_NAME = Object.keys(DLL_ENTRY);module.exports = &#123; DLL_ENTRY, DLL_CHUNKS_NAME &#125;;//dll.config.jsconst path = require('path');const webpack = require('webpack');const dllConstants = require('./dll.entry.js');module.exports = &#123; entry: dllConstants.DLL_ENTRY, output: &#123; filename: '[name].dll.js', // 动态链接库输出的文件名称 path: path.join(__dirname, '../dll'), // 动态链接库输出路径 libraryTarget: 'var', // 链接库(react.dll.js)输出方式 默认'var'形式赋给变量 b library: '_dll_[name]_[hash]' // 全局变量名称 导出库将被以var的形式赋给这个全局变量 通过这个变量获取到里面模块 &#125;, plugins: [ new webpack.DllPlugin(&#123; // path 指定manifest文件的输出路径 path: path.join(__dirname, '../dll', '[name].manifest.json'), context: __dirname, name: '_dll_[name]_[hash]' // 和library 一致，输出的manifest.json中的name值 &#125;) ]&#125;;//dll.utils.jsconst path = require('path');const constants = require('../conf/dll.js');const webpack = require('webpack');const CopyWebpackPlugin = require('copy-webpack-plugin');const HtmlIncludeAssetsPlugin = require('html-webpack-include-assets-plugin');//创建 dll 的关联包，返回[]// 当我们需要使用动态链接库时 首先会找到manifest文件 得到name值记录的全局变量名称 然后找到动态链接库文件 进行加载const createDllReferences = () =&gt; &#123; const dllChunks = constants.DLL_CHUNKS_NAME; const tmpArr = []; dllChunks.forEach(item =&gt; &#123; tmpArr.push( new webpack.DllReferencePlugin(&#123; manifest: require(path.join(__dirname, `../../dll/$&#123;item&#125;.manifest.json`)) //) &#125;) ); &#125;); return tmpArr;&#125;;//copy dll 的文件到输出目录const copyDllToAssets = () =&gt; &#123; const dllChunks = constants.DLL_CHUNKS_NAME; const tmpArr = []; dllChunks.forEach(item =&gt; &#123; tmpArr.push(&#123; from: `dll/$&#123;item&#125;.dll.js`, to: 'dll' &#125;); &#125;); return new CopyWebpackPlugin(tmpArr);&#125;;//对dll资源添加相对html的路径const addDllHtmlPath = () =&gt; &#123; const dllChunks = constants.DLL_CHUNKS_NAME; const tmpArr = []; dllChunks.forEach(item =&gt; &#123; tmpArr.push(`dll/$&#123;item&#125;.dll.js`); &#125;); return new HtmlIncludeAssetsPlugin(&#123; assets: tmpArr, // 添加的资源相对html的路径 append: false // false 在其他资源的之前添加 true 在其他资源之后添加 &#125;);&#125;;module.exports = &#123; createDllReferences, copyDllToAssets, addDllHtmlPath &#125;; 然后在build.config.js中加入dll插件： 123dllUtils.copyDllToAssets(),...dllUtils.createDllReferences(),dllUtils.addDllHtmlPath(), 5、缓存dll对于上文所说的，使用dll抽离第三方npm库可以加速打包，但还存在一种情况就是，dll可能很久不会改变，那每次build的时候都要重新生成dll包，要不然每次收到复制到指定目录。 参考node_modules的缓存机制，我们可以将生成的dll包缓存起来，每次检查对象dll.entry.js的md5值，只要dll的入口定义不变则认为无需生成新的dll包。具体配置就不写了，跟上面的差不多。 6、其他 开启devtool: &quot;#inline-source-map&quot;会增加编译时间 DedupePlugin插件可以在打包的时候删除重复或者相似的文件，实际测试中应该是文件级别的重复的文件 减少构建搜索或编译路径 缓存与增量构建:babel-loader可以缓存处理过的模块，对于没有修改过的文件不会再重新编译，cacheDirectory有着2倍以上的速度提升，这对于rebuild 有着非常大的性能提升。 二、React运行优化1、组件懒加载]]></content>
      <tags>
        <tag>React</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器持久化存储那些事]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[现在前后端分离是比较流行的开发方案，在 SPA 的开发过程中难免需要存储一些数据到浏览器，比如认证判断的 Token 。现代常用浏览器的本地持久存储方案基本分为Cookie、 LocalStorage（sessionStorage）和IndexedDB。本文就不讨论 Cookie了。 一、LocalStorage(sessionStorage)的概念LocalStorage 是 HTML5加入的一个新特性，从命名就知道其目的是作为本地存储来使用，解决了 Cookie 存储空间不足的问题，一般 LocalStorage 在浏览器的存储空间是5MB,而 Cookie中每条 cookie 大约是4KB。SessionStorage 与 LocalStorage 唯一的区别是：SessionStorage 在会话结束时就会被 清空数据，而LocalStorage 可以持久存储。 LocalStorage的优劣1、LocalStorage存储空间明显提升，可以存储较多的数据； 2、LocalStorage可以长久存储数据，只要存储一次就可以长久保留在本地，除非主动清空数据； 3、LocalStorage是 HTML5的新特性，只会被现代浏览器支持，IE8以下的IE浏览器就不支持该特性; 4、LocalStorage 只能存储字符串 5、在隐私模式下，不能使用 LocalStorage; 6、LocalStorage 不会被爬虫嗅探并抓取； 7、LocalStorage的使用是遵循同源策略。 LocalStorage的使用方法1、在使用 LocalStorage之前需要检测当前浏览器是否支持。 12345if(!window.localStorage)&#123; console.log("浏览器 不支持LocalStorage"); return ;&#125; //正常使用 LocalStorage 2、LocalStorage 的数据写入可以有3种方式，其实都是键值对操作： 123456789101112if(!window.localStorage)&#123; console.log("浏览器 不支持LocalStorage"); return ;&#125; //正常使用 LocalStorage const storage=window.localStorage; storage["count"]=1; storage.name='qimajiang'; //写入存储进去的搜索字符串类型 storage.setItem("other",3); 一般使用 storage.setItem这种方式比较好。 3、LocalStorage 的数据读取 123456789101112if(!window.localStorage)&#123; console.log("浏览器 不支持LocalStorage"); return ;&#125; //正常使用 LocalStorage const storage=window.localStorage; console.log(storage['count'])//1 console.log(storage.name);//'qimajiang' console.log(storage.getItem("other");)//3 一般使用 storage.getItem这种方式比较好。 4、LocalStorage 的其他数据操作 删除某个键值:window.localStorage.removeItem(&#39;key&#39;) 清空当前网站的LocalStorage：window.localStorage.clear() 一般使用 LocalStorage 来存储简单的数据（字符串）就可以满足了，但在日益复杂的应用开发中，难免需要存储复杂的结构化数据，而且有可能存储的数据超过5MB,这时我们就需要考虑使用 IndexedDB 了 二、IndexedDB 的概念1、IndexedDB顾名思义是一种内置在浏览器中数据库，而且是一种非关系型的数据库，即不需要编写SQL语句去操作数据库，而且存储的数据格式是JSON。 2、IndexedDB不像我们平时服务器上使用的 NoSQL 数据库，IndexedDB没有表的概念，在IndexedDB中是叫object store,其实平时就可以把object store看做数据表。 3、IndexedDB的每次操作都是一个事务，每一个对数据库操作是在一个事务的上下文中执行的。 4、IndexedDB的每次数据库操作都需要先打款object store，再执行指定的操作，不能一直打开某个object store。 5、IndexedDB的所有操作都是异步的。 三、IndexedDB在 React 中的实践因为我目前主要专注React项目的开发,而且IndexedDB的原生 api 有点奇怪，在我的项目中我是使用 Dexie这个基于IndexedDBapi 封装的操作库。后面就阐述一下如何使用Dexie进行IndexedDB的数据操作。 1、安装npm i -S dexie 2、在项目根目录建立一个db文件夹，新建一个文件db.js,在db.js中定义数据库； 123456789101112131415import Dexie from 'dexie';const db = new Dexie('HXDB');//系统所有权限列表的数据const SYSTEM_ALL_PERMISSIONS_SCHEMA = 'code, name, module';export const DEXIE_STORES_1 = &#123; SYSTEM_ALL_PERMISSIONS: SYSTEM_ALL_PERMISSIONS_SCHEMA&#125;;db.version(2).stores(DEXIE_STORES_1);db.version(1).stores(DEXIE_STORES_1);//定义版本db.open();//打开数据库export default db;//模块化导出 IndexedDB使用 version 来区分不同版本号，因为不同的版本可能使用不同的 store 结构，每次更改 store 的结构，需要增加 version 的值，而且旧的版本需要保留。 3、数据操作 在db目录中新建operations.js文件，定义一些常用的数据操作方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import db from 'db/db';/** * Created By xun on 2018-08-16 17:14. * Description: operations */export const getDBAllDataArray = async tableName =&gt; &#123; const myTable = await db[tableName]; return myTable.toArray();&#125;;export const getDBDataByKey = (tableName, key) =&gt; &#123; return db.table(tableName).get(key);&#125;;// 单个添加export const addDBData = (tableName, values) =&gt; &#123; return db.table(tableName).add(values);&#125;;// 批量添加export const addDBDataBatch = (tableName, values) =&gt; &#123; return db.table(tableName).bulkAdd(values);&#125;;//存在就更新， 否则添加export const softInsertDBData = async (tableName, values, key = null) =&gt; &#123; if (!key) &#123; return addDBData(tableName, values); &#125; const existed = await getDBDataByKey(tableName, key); if (existed) &#123; return db.table(tableName).update(key, values); &#125; else &#123; return addDBData(tableName, values); &#125;&#125;;//删除export const deleteDBDataByKey = async (tableName, key) =&gt; &#123; return db.table(tableName).delete(key);&#125;;//清空export const clearAllDBData = async tableName =&gt; &#123; return db.table(tableName).clear();&#125;; 若要增加其他特殊的数据操作，就直接在operations.js文件中增加方法即可，避免重复的编码。 IndexedDB理论上的存储空间是电脑硬盘容量的一般，所以存储空间超级充足了。 四、解决IndexedDB的异步问题前文有提到IndexedDB的所有数据操作都是异步的，在一些情况下我们需要模拟同步操作，例如把菜单的配置放在IndexedDB中，那么每次从IndexedDB获取到菜单定义数据后需要回调数据显示，有点麻烦。我在项目中使用mobx状态管理器来同步所有的IndexedDB数据，只有不刷新页面，就可以同步操作IndexedDB数据了。目前都是读取操作，数据都是从服务器配置好的，存储在IndexedDB是不需要每次从服务器获取。 一般在更新IndexedDB中数据的时候，就更新mobx中的 store数据。 五、总结浏览器的本次存储在现在 web 应用开发中还是比较重要的，掌握了这些前端本地存储方法有利于提升应用以及应用共享数据。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React一年的简单总结]]></title>
    <url>%2F2018%2F09%2F14%2F%E4%BD%BF%E7%94%A8React%E4%B8%80%E5%B9%B4%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[从2017年9月开始我转为前端开发，当时公司没有一个单纯专注前端的开发人员，我接到任务后首先是考虑的是应该使用哪种前端技术（框架）。在简单对比Angular、Vue 和 React 后，我选择了 React。因为我曾经花了时间了解过，而且我特别喜欢 React 的 JSX 语法和单向数据流绑定方式。本文就简单总结一下这一年我使用 React 的实际经验。 一、必须关注React 动态我开始使用 React时的版本是16.0.0，到现在16.5.0，我感受到最大的变化是：1、 新增了Context，翻译为：上下文。有了这个 API 我们可以简单的共享组件间的数据。比如：在向多级子组件传 props 时无需每一级组件都要传递 props。在顶级组件创建了Context.Provider,在任何子组件中使用Context.Consumer就可以获取到顶级组件的props。 2、 多种ref的创建方式。在最初，要访问 DOM ，需要在组件增加ref={myRef}，而且 ref 的值只能是string。到现在，我们不仅可以利用原来的方式创建（旧不被官方推荐），还可以 ref={ins =&gt; this.myRef = ins} ，ref 的值可以是一个函数；当然还可以这样: 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125; 3、 在16.3.0版本中，React 组件的生命周期增加了 static getDerivedStateFromProps(),getSnapshotBeforeUpdate(),componentDidCatch(),并且对componentWillReceiveProps()和componentWillUpdate()增加了不安全的前缀，如： UNSAFE_componentWillReceiveProps()。我们这里不展开讨论这些生命周期API改变给我们日常开发带来的影响。 4、 除了上面列出变化，还有 Fragment、异步渲染等等的改变与变化。在短短一年，React 的变化与改进很大，这也要我们开发者需要时刻关注 React 的动态，养成习惯去 React官网查看每个版本的变化日志，这样才有助于改进我们的应用，能更好的掌握 React。 二、掌握Babel 和Webpack的配置1、Babel 总结Babel 是现代化前端开发的关键角色，Babel 的存在才使得我们可以用 ES6、ES7，甚至 ES8的新特性来开发前端项目。因为 我们的项目基本是运行在浏览器上的，每个浏览器的 JS 支持情况不一致，当使用Babel把我们的项目代码转译成 ES5，可以最大程度兼容目标浏览器列表。在2017年，Babel的 presets 需要我们手动引入所需要的包，如：babel-preset-latest、babel-preset-react、babel-preset-es2015和babel-preset-stage-0。很多时候我们很难确定我们具体需要哪个包，因为不知我们会在项目中使用什么新特性。babel-preset-env的出现改变这一现象，可以根据我们设置的浏览器列表，按需选择语法环境包。尤其现在 Babel7的发布，使得 Babel 配置更加简单了。 2、Webpack 总结Wepack是工程化前端开发的基础。我创建第一个React SPA 项目的时候，没有使用 CRA(create-react-app),因为我当时觉得，既然我刚接触现代前端开发方式，我就要从零开始学习，那当然是从 Webpack 配置开始学习了。Webpack作为现在最流行的打包工具， 但由于其松散的配置方式和插件化配置使得整个 Webpack配置让人看起来十分复杂，因此让很多人望而却步，不敢真正去了解 Webpack 配置项的意义。其实，Webpack 配置没那么难，尤其现在 Webpack4的出现，可以说可以是零配置了。在项目开始的时候，只需要配置入口，出口、css 加载器和 js 加载器就可以项目运行起来了。至于其他的配置，用到的时候再添加也不迟。配置优化更加不能急，项目的完成度没有到达90%，谈优化是多余的。这一年来， 我项目中 Webpack 配置不知改了多少次了，这种东西并不是说开始配置好了就不用再改动了。所以我们一步一步来，就可以慢慢熟悉整个 Webpack 配置的诀窍了。 三、代码拆分1、 React组件拆分我特别喜欢React的组件化开发，在开发过程中我们可以重用组件。当一个页面的功能增多时，代码数肯定飙升的。这个时候我们可以考虑把一些功能拆分出来，不仅使得当前文件代码减少，增加可读性，而且说不定当前拆分的小功能组件可以被其他页面重用，减少重复的工作量。不用害怕拆分，哪怕是一个按钮都可以抽取到一个独立的组件中，比如：在我的项目中，我的一个小小的删除按钮就拆分出来，因为每个删除按钮都需要一个弹窗按钮来包裹，每次写按钮功能时，都要重复的用弹窗组件来包裹，拆分一个自定义的删除按钮就让我们每次只需要引用我们的资金的删除按钮即可。当然，组件的拆分可以拆分成无状态组件、正常功能组件，甚至是自定义业务组件库。我在前面的文章写过自建公司内部的 React 业务组件库，因为这些组件不只是可以在当前项目使用，多个项目实行相同的功能时，不断的 copy 也是增加工作量。 2、逻辑函数拆分我们都知道一个函数方法只实现一种功能，一般来说每个页面都是特定的功能，但总会存在相同的数据处理方式。这个时候我们创建一个函数库，把常用的数据处理方法抽取出来，在别的页面使用时就可以简单实现了。比如：在判断值是否有效时，虽然是很简单的方法，但每次都要这样判断 null、undefined以及````(空串),着实让人感觉麻烦。 3、常量配置的拆分我们做 SPA，接口作为最大的常量配置项，我们必须用单独的文件来声明这些接口，因为不可能一个接口只用在一个地方，当接口路径改变时，我们只需要在接口声明文件中更改一次即可。而且不能模块的接口需要拆分到不同的文件中，增加可读性。还有其他的一些页面配置声明都可以放到统一目录下（constants目录），这样不仅让项目结构更加清晰，而且增加代码的健壮性。 四、不断的重构、重构这一年来，项目功能在不断变化，这样也带来项目代码页不断变化，出来不断拆分代码之外。我们要不断的对每个功能的实现方式不断重构，也行以前需要用10行代码才能解决的问题，现在想到了一个更好的方法，只需要5行了。在我的项目中，我重构最多的是应用的路由，从开始只是使用页面级别的路由，到现在每个组件都使用路由，其中重构的次数不下与10次。也许我一开始就应该考虑这种路由方式了，但当时是一个简单的项目就没必要搞那么复杂吧。并不是我不想这样做，只是必要性太低了。其实重构的过程，也是对代码进行改进的过程，随着开发时间的增加，对代码使用的理解不一样了，重构让我更升入理解了 React 的一些 API。只要我有空， 我就会 review 项目的代码，看看哪些地方可以改进，包括 Babel Webpack 配置的重构。 五、代码规范和团队协作一个好的项目不只是说功能完成了就可以了，除了不断重构之外，在每次的编码过程中注意编码规范还是十分重要的。因为代码是写给人看的，自己看的懂的代码，团队成员不一定能看懂。除了代码需要格式化之外，还需要一定的注释，在逻辑复杂的地方增加一定的注释，方便团队成员和日后自己的 review 代码时能看懂该段代码，也会对优化带来启示的。在 Rect 这样的前端项目中，一般使用 ESLint 进行语法规范、用Prettirer进行代码美化，而且还要对编辑器进行美化编写规则，如.editorconfig,让团队成员的在其编辑器上写出的代码与自己的风格一致。 六、尝试使用高级特性在项目开发开始阶段中，我们因为专注于业务功能的实现，容易忽略一些功能其实可以用高级特性来实现。这就让我们在重构的过程中考虑是否使用高级特性来替代当前的实现逻辑了。使用高级特性不仅让我们的项目代码简洁、还可以让我更好的理解React、JS 的高级特性，这样的项目开发方式才能最大程度提升自己的水平。 七、使用 TypeScript吧由于项目开始时，我对 TypeScript 一无所知，压根没考虑过使用 TypeScript 来实现。对应 TypeScript 的有点和在 React 的使用方式，我在前面的文章有写过。现在我最苦恼的是，我很想使用 TypeScript 来开发，但把现在的项目代码转为 TypeScript 的工作量实在太大了。因此，我们应尽可能在项目使用 TypeScript!!! 八、解决困难的能力我觉得开发是一件很快乐的事情，开发过程遇到困难 首先尝试自己解决，才能提升自己；也不要吝啬帮助别人，也许别人遇到的问题正是自己前不久刚解决的，这样能加深印象。 最后本文简单总结了这一年我的 React 开发经验，希望能帮到大家。]]></content>
      <tags>
        <tag>React</tag>
        <tag>总结</tag>
        <tag>Webpack</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript开发笔记]]></title>
    <url>%2F2018%2F08%2F21%2FTypeScript%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在上一篇的文章中，学习了 TypeScript 的基本知识，以及 TS 在 React中的基本使用方法。在本文中，我们深入了解 TS在 React 中的实践。本文将采用 ant-design 作为基础的 UI 框架。 一、用 TS 创建 React 的 SFC(无状态组件)在本次实践中，我们基于 antd 创建一个统一的 Input Form组件。该组件可以同时支持基本 Input、InputNumber和 Input.Text,我们将定义 elementTypeEnum来判断该使用哪个输入组件。 1、引入 antd 的 Form, Input, InputNumber组件（HXInputItem） 12import &#123; Form, Input, InputNumber &#125; from "antd"; 2、定义输入类型的枚举 123456enum elementTypeEnum &#123; normal = "normal",//普通的字符串输入 number = "number",//数字输入，对应antd的 InputNumber text = "text"//文本输入，对应 antd 的 Input.Text&#125; 3、创建 HXInputItem 的属性声明 1234567891011interface HXInputProps &#123; label: string;//输入框的标签 name: string;//输入框的变量名 getFieldDecorator: (name, options) =&gt; any;//antd 的 Form 装饰器 fieldDecoratorOptions: object;//antd Form 的表单域配置 formLayout?: object;//antd 的 formLayout inputProps?: object;//对应 antd 的输入框的属性配置 formItemProps?: object;//antd的 Form.Item的属性配置 elementType?: elementTypeEnum;//表示使用哪种输入组件，默认normal&#125; 4、创建 HXInputItem的 SFC 这一步非常重要，跟普通 React创建 SFC 有点区别。具体用法如下： 12const HXInputItem: React.SFC&lt;HXInputProps&gt; = props =&gt; &#123;&#125; 可以看到在 TS 创建 SFC 需要使用 React.SFC属性，否则无法创建成功。 5、填充我们的 HXInputItem SFC 123456789101112131415161718192021222324252627282930//把当前传入的属性通过解构获取。const &#123; label, name, getFieldDecorator, formLayout, fieldDecoratorOptions, inputProps, formItemProps, elementType &#125; = props; return ( &lt;FormItem &#123;...formLayout&#125; label=&#123;&lt;span className="form-label-text"&gt;&#123;label&#125;&lt;/span&gt;&#125; colon=&#123;false&#125; hasFeedback &#123;...formItemProps&#125; &gt; &#123;getFieldDecorator(name, fieldDecoratorOptions)( elementType === "normal" ? ( &lt;Input &#123;...inputProps&#125; /&gt; ) : elementType === "number" ? ( &lt;InputNumber &#123;...inputProps&#125; /&gt; ) : ( &lt;Input.TextArea rows=&#123;5&#125; key=&#123;name&#125; &#123;...inputProps&#125; /&gt; ) )&#125; &lt;/FormItem&gt; ); 通过elementType的值，调用不同的antd 中的输入组件，在项目中只引入当前SFC即可，让开发更加便利，快速和统一。若在以后的开发过程，存在特殊的需要，稍微兼容改造一下该组件即可，减少代码量。 6、声明该 SFC 的默认属性 1234HXInputItem.defaultProps = &#123; elementType: elementTypeEnum.normal&#125;; 7、导出该组件 1export default HXInputItem; 二、用TS 加载远程数据(fetch Api)1、定义 http Response 的 Interface 12345678910111213export default interface IRestRes &#123; message?: string | null;//可以是 undefined、null、string类型， code?: number; filename?: string | null;//请求文件时的文件名 data?: any;//普通 JSON 数据、file 二进制数据 loginAccount?: string; name?: string; roles?: Array&lt;string&gt;;// 可以是undefined、字符串的数组 token?: string; type?: string | null; total?: number;&#125; 2、定义统一的获取 JSON 数据的 fetch 方法 12345678910111213141516171819202122232425262728293031/* ** @desc 所有fetch请求的json 数据的基础； @author qimajiang * @param options object* @param url stirng* @return IRestRes Promise*/export const initialFetch = (url:string, options:Object): Promise&lt;IRestRes&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const finalOpts = &#123; headers: new Headers(&#123; Authorization: myToken,//登录后需要传入该 header &#125;), ...options &#125;; fetch(url, finalOpts) .then(res =&gt; &#123; console.log(res); return res.text(); &#125;) .then(text =&gt; &#123; // TODO:拦截所有响应， 处理 token 失效等情况 responseMiddleware const resJson = text ? JSON.parse(text) : &#123;&#125;; resolve(resJson as IRestRes);//将响应数据转换为IRestRes &#125;) .catch(e =&gt; &#123; reject(e);//请求失败的错误捕捉 &#125;); &#125;);&#125;; 3、使用 fetch 的 get方法，请求JSON 数据 1234567891011121314151617181920/* *通用 fetchGetJson*/export const fetchGetRequest = (api:string, params?:Object): Promise&lt;IRestRes&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let url = new URL(api);//构造url url.search = new URLSearchParams(params);//构造 search initialFetch(url, &#123; method: "GET" &#125;) .then(response =&gt; &#123; console.log(response, 766); resolve(response); &#125;) .catch(e =&gt; &#123; reject(e); &#125;); &#125;);&#125;; 3、使用 fetch 的 post，提交表单(FormData) 123456789101112131415161718192021222324252627282930313233343536/**通用 提交表单*/export const fetchPostForm = (url:string, values:object=&#123;&#125;): Promise&lt;IRestRes&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const formData = new FormData(); Object.keys(values).forEach(key =&gt; &#123;//手动构造 FormData const vl = values[key]; if (vl) &#123; if (vl.constructor !== Array) &#123; formData.append(key, vl); &#125; else &#123; // 数组的数据 // console.log(' 是数组，多个文件') const fileList = vl; for (let i = 0; i &lt; fileList.length; i++) &#123; const item = fileList[i]; // console.log('每个文件内容',item,i, '数组长度',fileList.length) formData.append(key, item); &#125; &#125; &#125; &#125;); initialFetch( url, &#123; method: "POST", body: formData // data can be `string` or &#123;object&#125;! &#125;) .then(response =&gt; &#123; console.log(response, 766); resolve(response); &#125;) .catch(e =&gt; &#123; reject(e); &#125;); &#125;);&#125;; 4、使用 fetch 获取文件流 1234567891011121314151617181920212223242526272829303132/* *通用 fetchGetFile 获取文件*/export const fetchGetFile = (api:string, params?:obejct): Promise&lt;IRestRes&gt; =&gt; &#123; let url = new URL(api); return new Promise((resolve, reject) =&gt; &#123; const finalOps = &#123; headers: new Headers(&#123; Authorization: myToken, "Access-Control-Allow-Origin": BASE_URL,//服务端必须响应 该header，否则无法获取到 Content-Disposition &#125;), ...params &#125;; fetch(url, finalOps) .then(async res =&gt; &#123; // TODO:拦截所有响应， 处理 token 失效等情况 responseMiddleware const contentDisposition = res.headers.get("Content-Disposition"); const myBlob = await res.blob(); const Ires: IRestRes = &#123; data: myBlob, type: res.headers.get("Content-Type"), filename: decodeURI( String(contentDisposition).replace("attachment;filename=", "") || "" ) &#125;; resolve(Ires); &#125;) .catch(e =&gt; &#123; reject(e); &#125;); &#125;);&#125;; 三、 使用 TS创建普通的 React 组件先上完整的组件代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import * as React from "react";import &#123; observer, inject &#125; from "mobx-react";import IStore from "../../interface/IStore";import SearchType from "../../enum/SearchType";// const styles = require("./styles/index.less");interface SearchBoxProps &#123; store?: IStore; placeholder?: string;&#125;interface SearchBoxState &#123; focus: boolean; focusLock: boolean; searchField: SearchType; words: string; searching: boolean;&#125;@inject("store")@observerexport default class SearchBox extends React.Component&lt;SearchBoxProps, SearchBoxState&gt; &#123; constructor(props) &#123; super(props); this.state = &#123; focus: false, focusLock: false, searchField: SearchType.SEARCH_FIELD_ALL, words: "", searching: false &#125;; &#125; static defaultProps : &#123; placeholder: '输入关键词并搜索' &#125; onFocus = () =&gt; &#123; this.setState(&#123; focus: true &#125;); &#125;; onBlur = () =&gt; &#123; if (this.state.focusLock) &#123; return; &#125; this.setState(&#123; focus: false &#125;); &#125;; onMouseEnter = () =&gt; &#123; this.setState(&#123; focusLock: true &#125;); &#125;; onMouseLeave = () =&gt; &#123; this.setState(&#123; focusLock: false &#125;); &#125;; render() &#123; return ( &lt;div onFocus=&#123;this.onFocus&#125; onBlur=&#123;this.onBlur&#125; onMouseEnter=&#123;this.onMouseEnter&#125; onMouseLeave=&#123;this.onMouseLeave&#125; /&gt; ); &#125;&#125; 有看出与普通 JS 创建React 组件的区别了吗？ （1）、使用泛型定义组件的 props 与 state； (2)、创建默认的 state 值，必须在SearchBoxState已经定义，否则出错。 (3)、 defaultProps 需要使用 static 修饰 四、创建 d.ts 文件 在项目根目录创建 typings 的文件夹，在 typings 中创建 index.d.ts 文件中输入以下内容 123interface Promise&lt;T&gt; &#123; finally: (callback) =&gt; Promise&lt;T&gt;;&#125; 由于我们在使用 fetch 请求数据时，返回的数据使用 Promise&lt;IRestRes&gt;返回。如果不创建上门的 d.ts，编辑器在编译时可能无法Promise&lt;IRestRes&gt;。为什么呢？ 因为： typings的存在是为了方便TypeScript识别、编译、智能提示TypeScript无法识别的JS库的特性和语法。 五、总结TS在 React 的使用远不止这些，本文只是抛砖引玉，让我们对 TS 的了解更加深入，而且更是感叹 TS 的强大。]]></content>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 与 React]]></title>
    <url>%2F2018%2F07%2F28%2FTypeScript%20%E4%B8%8E%20React%20%2F</url>
    <content type="text"><![CDATA[最近开发工作缓下来了， 就抽时间看看传说中的神器 TypeScript。主要描述一些 TypeScript 在 React 项目中的一些使用方法。 一、TypeScript 是什么TypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScipt。TypeScript可以在任何浏览器、任何计算机和任何操作系统中运行， 并且它是开源 的。 二、 TypeScript 的基础知识1、 TypeScript 的基本类型：TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的元组、枚举类型方便我们使用。如：let exist: boolean = false 2、TypeScript 的变量声明：let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。这跟 JavaScript 的其他变量用法几乎一模一样。 3、 TypeScript 的接口：TypeScript的核心原则之一是对值所具有的结构进行类型检查。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。接口中属性的顺序不影响接口的判断。 接口的定义： 12345interface IPerson &#123; name: string; age? number; readonly gender: string; &#125; 在属性后加上？表示该属性的可选的，否则的必要条件; 在属性名前加上readonly表示实现该接口后（对象字面量构造），该属性只读，不能写入新的值。 接口的对象构造 1const me: IPerson = &#123;name: "qimajiang", age: 25, gender: "男"&#125; 跟变量的声明差不多， 只是类型是自定义的。 4、TypeScript 的类：传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类的基础用法 1234567891011121314class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; say() &#123; return "Hello, " + this.name; &#125;&#125;let person = new Person("qimajiang");const sayHello = person.say(); // Hello, qimajiang 类的继承用法， 跟 Java 或其他编程语言一样， 类是可以继承的。用法如下： 12345678910111213class Man extends Person &#123; constructor(name: string) &#123; super(name) &#125; getGender() &#123; console.log('I am a man'); &#125;&#125;const man = new Man("qimajaing")const manSay = man.say(); const gender = man.getGender(); TypeScript 的类中也可以使用修饰符来限制类中属性或方法的访问。 修饰符有： public、private、protected、readonly 关于类的更多知识， 访问 https://www.tslang.cn/docs/handbook/classes.html 5、TypeScript的函数：和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。在 TypeScript 中的参数、返回值、中间变量都可以指定类型。这样让编写的函数更加安全稳定健壮、在 IDE 中还可以智能提示，加快编码效率，降低错误率。如： 12345function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能; 默认参数、剩余参数、箭头函数或其他用法与 在JavaScript 中的一样。 到目前为止，主要学习了 TypeScript 的最基础知识，足够创建一些最基本的 web 应用了。至于 TypeScript 的其他语法：泛型、枚举等等，就不再一一展开了，可访问https://www.tslang.cn/docs/handbook/查看.三、 JSX1、JSX 知识JSX是一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX因 React框架而流行，但是也被其它应用所使用。 TypeScript支持内嵌，类型检查和将JSX直接编译为JavaScript。想在 TypeScript 使用 jsx，必须做到： 1、给文件一个 .tsx扩展名2、启用 jsx选项 TypeScript具有三种JSX模式：preserve， react和 react-native。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在 preserve模式下生成代码中会保留JSX以供后续的转换操作使用（比如： Babel）。 另外，输出文件会带有 .jsx扩展名。 react模式会生成 React.createElement，在使用前不需要再进行转换操作了，输出文件的扩展名为 .js。 react-native相当于 preserve，它也保留了所有的JSX，但是输出文件的扩展名是 .js。 2、TypeScript 与 React 的整合要想一起使用JSX和React，要使用 React类型定义。 这些类型声明定义了 JSX合适命名空间来使用React。 四、创建TypeScript风格的React应用1、 安装 TypeScript 版本的定义依赖包：（1）在原有的 React 项目，除了安装 react，还需要安装@types/react,若其他 react 库存在@types 定义包， 也一并下载安装。 （2）如果是使用 create-react-app 创建 React 项目， 可以在创建时增加参数--scripts-version=react-scripts-ts，就好创建 TS 风格的 React 项目了。 2、 weback 配置至少要增加 ts 的配置 { test: /\.tsx?$/, loader: &quot;ts-loader&quot; }, 2、注意事项（1）在普通的 React项目中，我一般这样引用 React，import React from &#39;react&#39;,但在 TS 风格的 React 项目中， 需要这样import * as React from &#39;react&#39; （2） 创建无状态组件也有区别，具体分析下一篇展开。 （3） TS 风格 React 项目中，组件的状态和属性定义，尽可能用Interface声明。 (4) 要习惯对每个变量声明数据类型，减少出错概率，也方便 Debug。 五、总结本人主要学习了 TypeScrip 的一些常用特性， 以及如何创建一个 TS 风格的 React 项目。更多的TS 实战，后面会结合项目开发记录下来。]]></content>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 ESLint、Prettier 和 StyleLint美化 React 代码]]></title>
    <url>%2F2018%2F06%2F24%2F%E4%BD%BF%E7%94%A8%20Eslint%20%E5%92%8C%20Prettier%E7%BE%8E%E5%8C%96%20React%20%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在日常开发工作中， 一个项目不止一个开发者， 但是每个人的代码质量、风格、格式规范肯定不一致，带来的影响是整个项目看上去比较零散、奇怪。那有没有方法使得所有人写出来的代码质量、风格一致呢？那就要使用 ESLint 进行质量检查和修复；使用 Prettier 进行美化、格式化，比如缩进、行的最大长度等等；在样式的编写中，大量的css和scss代码书写中，或多或少会出现问题，可以使用 StyleLint对样式代码进行格式化。以上俗称：静态代码分析。 一、ESlint 基本知识1、概念ESLint是一个插件化的javascript代码检测工具，它可以用于检查常见的JavaScript代码错误，也可以进行代码风格检查，这样我们就可以根据自己的喜好指定一套ESLint配置，然后应用到所编写的项目上，从而实现辅助编码规范的执行，有效控制项目代码的质量。 2、使用方法在开始使用ESLint之前，我们需要通过NPM来安装它： 12npm install -g eslint 创建一个 js 文件，如：test.js, 内容随意，但要能正常运行。 用 ESLint检查上述文件： 12eslint test.js 基本使用就是如此简单，后面说如何集成到项目中。 3、高级用法12eslint --fix -e node_modules -c .eslintrc –fix： 如果检查到问题，自动根据配置修改代码。 -e：排除检查文件夹。 -c：使用指定的 eslint 配置文件 二、Prettier 基本知识1、概念 Prettier 是一个“有主见”的代码格式化工具，能够使输出代码保持风格一致。它通过解析代码和使用自定义规则重新打印代码，使得整个项目的代码格式一致。Prettier 支持多种语言，它的一大特点就是能够支持命令行、API 等多种形式调用，可以让团队保持代码风格一致。包括 React 在内的很多项目已经开始使用了。支持列表： JavaScript，包括 ES2017 JSX Flow TypeScript CSS、LESS 和 SCSS JSON GraphQL 2、使用方法 在开始使用Prettier之前，我们需要通过NPM来安装它： 12npm install -g prettier 继续使用刚才创建的 test.js, 直接使用命令: 12prettier --write 三、StyleLint 基本知识1、概念stylelint 是一个强大和现代的 CSS 审查工具，有助于开发者推行统一的代码规范，避免样式错误。stylelint 由 PostCSS 提供技术支持，所以它也可以理解 PostCSS 解析的语法，比如 SCSS 基础用法在开始使用StyleLint前，需要使用 NPM 安装： 12npm install -g stylelint 创建一个样式文件， 如：style.less, 内容随意， 但需要正确。 直接使用命令: 12stylelint test.less --syntax less –syntax是指定语法， 可选为 sass 或 scss等。 四、在项目中 ESLint、 Prettier和 StyleLint虽然 ESLint和 Prettier 在格式化代码方式确实有重叠的地方， 但两者的侧重点不一样。所有一般在项目中， 我习惯同时使用两者对项目代码进行检查和规范美化。 1、安装 ESLint 到 React项目需要安装 的包如下：12345"babel-eslint": "^8.2.3","eslint": "^4.19.1","eslint-config-standard-jsx": "^5.0.0","eslint-plugin-react": "^7.9.1", babel-eslint是指需要检查 babel 转译后的代码。 在项目根目录创建配置文件 .eslintrc对.eslintrc文件写入以下内容： 12345678910111213141516171819202122232425262728293031&#123; "parser": "babel-eslint", "plugins": ["react"], "extends": ["standard-jsx", "plugin:react/recommended"], "parserOptions": &#123; "sourceType": "module" &#125;, "env" : &#123; "es6": true, "browser" : true, "node": true, "commonjs": true &#125;, "rules": &#123; "no-mixed-spaces-and-tabs": "off", "camelcase": "warn", "eqeqeq": "warn", "curly": "error", "no-undef": "error", "no-unused-vars": [0, &#123; "vars": "all", "args": "none" &#125;], "max-params": "warn", "no-console": "off", "no-unreachable":"warn", "react/jsx-indent": "off", "jsx-quotes": "warn", "react/jsx-indent-props": "off", "react/display-name": "off", "react/prop-types": "warn" &#125;&#125; 检查环境包括： es6、浏览器、nodejs 和 commonjs。 rules 的配置项可自行增减和修改，每个配置项的可选值一般为3个： off、warn 和 error eslint 所有规则配置解读如下（值可修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175"no-alert": 0,//禁止使用alert confirm prompt"no-array-constructor": 2,//禁止使用数组构造器"no-bitwise": 0,//禁止使用按位运算符"no-caller": 1,//禁止使用arguments.caller或arguments.callee"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名"no-class-assign": 2,//禁止给类赋值"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句"no-console": 2,//禁止使用console"no-const-assign": 2,//禁止修改const声明的变量"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)"no-continue": 0,//禁止使用continue"no-control-regex": 2,//禁止在正则表达式中使用控制字符"no-debugger": 2,//禁止使用debugger"no-delete-var": 2,//不能对var声明的变量使用delete操作符"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;"no-dupe-args": 2,//函数参数不能重复"no-duplicate-case": 2,//switch中的case标签不能重复"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句"no-empty": 2,//块语句中的内容不能为空"no-empty-character-class": 2,//正则表达式中的[]内容不能为空"no-empty-label": 2,//禁止使用空label"no-eq-null": 2,//禁止对null使用==或!=运算符"no-eval": 1,//禁止使用eval"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值"no-extend-native": 2,//禁止扩展native对象"no-extra-bind": 2,//禁止不必要的函数绑定"no-extra-boolean-cast": 2,//禁止不必要的bool转换"no-extra-parens": 2,//禁止非必要的括号"no-extra-semi": 2,//禁止多余的冒号"no-fallthrough": 1,//禁止switch穿透"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3."no-func-assign": 2,//禁止重复的函数声明"no-implicit-coercion": 1,//禁止隐式转换"no-implied-eval": 2,//禁止使用隐式eval"no-inline-comments": 0,//禁止行内备注"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）"no-invalid-regexp": 2,//禁止无效的正则表达式"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量"no-irregular-whitespace": 2,//不能有不规则的空格"no-iterator": 2,//禁止使用__iterator__ 属性"no-label-var": 2,//label名不能与var声明的变量名相同"no-labels": 2,//禁止标签声明"no-lone-blocks": 2,//禁止不必要的嵌套块"no-lonely-if": 2,//禁止else语句内只有if语句"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）"no-mixed-requires": [0, false],//声明时不能混用声明类型"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格"linebreak-style": [0, "windows"],//换行风格"no-multi-spaces": 1,//不能用多余的空格"no-multi-str": 2,//字符串不能用\换行"no-multiple-empty-lines": [1, &#123;"max": 2&#125;],//空行最多不能超过2行"no-native-reassign": 2,//不能重写native对象"no-negated-in-lhs": 2,//in 操作符的左边不能有!"no-nested-ternary": 0,//禁止使用嵌套的三目运算"no-new": 1,//禁止在使用new构造一个实例后不赋值"no-new-func": 1,//禁止使用new Function"no-new-object": 2,//禁止使用new Object()"no-new-require": 2,//禁止使用new require"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()"no-octal": 2,//禁止使用八进制数字"no-octal-escape": 2,//禁止使用八进制转义序列"no-param-reassign": 2,//禁止给参数重新赋值"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接"no-plusplus": 0,//禁止使用++，--"no-process-env": 0,//禁止使用process.env"no-process-exit": 0,//禁止使用process.exit()"no-proto": 2,//禁止使用__proto__属性"no-redeclare": 2,//禁止重复声明变量"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错"no-return-assign": 1,//return 语句中不能有赋值表达式"no-script-url": 0,//禁止使用javascript:void(0)"no-self-compare": 2,//不能比较自身"no-sequences": 0,//禁止使用逗号运算符"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]"no-sync": 0,//nodejs 禁止同步方法"no-ternary": 0,//禁止使用三目运算符"no-trailing-spaces": 1,//一行结束后面不要有空格"no-this-before-super": 0,//在调用super()之前不能使用this或super"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";"no-undef": 1,//不能有未定义的变量"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined"no-undefined": 2,//不能使用undefined"no-unexpected-multiline": 2,//避免多行表达式"no-underscore-dangle": 1,//标识符不能以_开头或结尾"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;"no-unreachable": 2,//不能有无法执行的代码"no-unused-expressions": 2,//禁止无用的表达式"no-unused-vars": [2, &#123;"vars": "all", "args": "after-used"&#125;],//不能有声明后未被使用的变量或参数"no-use-before-define": 2,//未定义前不能使用"no-useless-call": 2,//禁止不必要的call和apply"no-void": 2,//禁用void操作符"no-var": 0,//禁用var，用let和const代替"no-warning-comments": [1, &#123; "terms": ["todo", "fixme", "xxx"], "location": "start" &#125;],//不能有警告备注"no-with": 2,//禁用with"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格"arrow-parens": 0,//箭头函数用小括号括起来"arrow-spacing": 0,//=&gt;的前/后括号"accessor-pairs": 0,//在对象中使用getter/setter"block-scoped-var": 0,//块语句中使用var"brace-style": [1, "1tbs"],//大括号风格"callback-return": 1,//避免多次调用回调什么的"camelcase": 2,//强制驼峰法命名"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号"comma-spacing": 0,//逗号前后的空格"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾"complexity": [0, 11],//循环复杂度"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的"consistent-return": 0,//return 后面是否允许省略"consistent-this": [2, "that"],//this别名"constructor-super": 0,//非派生类不能调用super，派生类必须调用super"curly": [2, "all"],//必须使用 if()&#123;&#125; 中的&#123;&#125;"default-case": 2,//switch语句最后必须有default"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾"dot-notation": [0, &#123; "allowKeywords": true &#125;],//避免不必要的方括号"eol-last": 0,//文件以单一的换行符结束"eqeqeq": 2,//必须使用全等"func-names": 0,//函数表达式必须有名字"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式"generator-star-spacing": 0,//生成器函数*的前后空格"guard-for-in": 0,//for in循环要用if语句过滤"handle-callback-err": 0,//nodejs 处理错误"id-length": 0,//变量名长度"indent": [2, 4],//缩进风格"init-declarations": 0,//声明时必须赋初值"key-spacing": [0, &#123; "beforeColon": false, "afterColon": true &#125;],//对象字面量中冒号的前后空格"lines-around-comment": 0,//行前/行后备注"max-depth": [0, 4],//嵌套块深度"max-len": [0, 80, 4],//字符串最大长度"max-nested-callbacks": [0, 2],//回调嵌套深度"max-params": [0, 3],//函数最多只能有3个参数"max-statements": [0, 10],//函数内最多有几个声明"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用"new-parens": 2,//new时必须加小括号"newline-after-var": 2,//变量声明后是否需要空一行"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格"object-shorthand": 0,//强制对象字面量缩写语法"one-var": 1,//连续声明"operator-assignment": [0, "always"],//赋值运算符 += -=什么的"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首"padded-blocks": 0,//块语句内行首行尾是否要空行"prefer-const": 0,//首选const"prefer-spread": 0,//首选展开运算"prefer-reflect": 0,//首选Reflect的方法"quotes": [1, "single"],//引号类型 `` "" ''"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号"radix": 2,//parseInt必须指定第二个参数"id-match": 0,//命名检测"require-yield": 0,//生成器函数必须有yield"semi": [2, "always"],//语句强制分号结尾"semi-spacing": [0, &#123;"before": false, "after": true&#125;],//分号前后空格"sort-vars": 0,//变量声明时排序"space-after-keywords": [0, "always"],//关键字后面是否要空一格"space-before-blocks": [0, "always"],//不以新行开始的块&#123;前面要不要有空格"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格"space-in-parens": [0, "never"],//小括号里面要不要有空格"space-infix-ops": 0,//中缀操作符周围要不要有空格"space-return-throw-case": 2,//return throw case后面要不要加空格"space-unary-ops": [0, &#123; "words": true, "nonwords": false &#125;],//一元运算符的前/后要不要加空格"spaced-comment": 0,//注释风格要不要有空格什么的"strict": 2,//使用严格模式"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()"valid-jsdoc": 0,//jsdoc规则"valid-typeof": 2,//必须使用合法的typeof的值"vars-on-top": 2,//var必须放在作用域顶部"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格"wrap-regex": 0,//正则表达式字面量用小括号包起来"yoda": [2, "never"]//禁止尤达条件 在 package.json的 scripts配置中增加命令12"lint:es": "eslint -c .eslintrc src/**/*.js --fix", 2、安装Prettier 到 react 项目需要安装的包如下：12"prettier": "^1.13.5", 在项目根目录创建配置文件 .prettierc写入内容： 1234567891011121314151617181920212223242526272829303132333435363738&#123; "printWidth": 100, "tabWidth": 2, "parser": "babylon", "trailingComma": "none", "jsxBracketSameLine": true, "semi": true, "singleQuote": true, "overrides": [ &#123; "files": [ "*.json", ".eslintrc", ".tslintrc", ".prettierrc", ".tern-project" ], "options": &#123; "parser": "json", "tabWidth": 2 &#125; &#125;, &#123; "files": "*.&#123;css,sass,scss,less&#125;", "options": &#123; "parser": "postcss", "tabWidth": 4 &#125; &#125;, &#123; "files": "*.ts", "options": &#123; "parser": "typescript" &#125; &#125; ]&#125; 主要配置了：缩进长度是2、单行长度是100、使用单引号等等。 在 package.json的 scripts配置中增加命令12"format": "prettier --write" 3、安装 StyleLint 到 React 项目需要安装的包123"stylelint": "^9.3.0","stylelint-config-standard": "^18.2.0", 在项目根目录创建配置文件 .stylelintrc写入内容： 1234567891011121314151617181920212223242526272829303132&#123; "extends": "stylelint-config-standard", "rules": &#123; "at-rule-empty-line-before": null, "at-rule-name-space-after": null, "comment-empty-line-before": null, "declaration-bang-space-before": null, "declaration-empty-line-before": null, "declaration-colon-newline-after": null, "function-comma-newline-after": null, "function-name-case": null, "function-parentheses-newline-inside": null, "function-max-empty-lines": null, "function-whitespace-after": null, "value-list-comma-newline-after": null, "indentation": null, "number-leading-zero": null, "number-no-trailing-zeros": null, "rule-empty-line-before": null, "selector-combinator-space-after": null, "selector-list-comma-newline-after": null, "selector-pseudo-element-colon-notation": null, "unit-no-unknown": null, "value-list-max-empty-lines": null, "no-empty-source": null, "selector-combinator-space-before": null, "selector-pseudo-class-no-unknown": null, "no-descending-specificity": null, "font-family-no-missing-generic-family-keyword": null &#125;&#125; 在 package.json的 scripts配置中增加命令12"lint:style": "stylelint \"src/**/*.less\" --syntax less", 该项目所有样式都是使用 LESS编写。 五、Pre-commit Hook 约束代码提交上文探讨了 ESLint、Prettier和 StyleLint 在项目中的使用方法和配置文件的编写，这都是针对个人的推荐操作； 为了保证该项目所有的参与者都能统一代码风格， 则需要采用强制约束；假如团队使用 Git昨晚代码托管工具， 在 commit行为和之前进行代码约束， 以便代码质量和风格一致。因此可借助 Husky 和 lint-staged 来实现。 Husky ：可以方便的让你通过npm scripts来调用各种git hooks。 lint-staged ：利用git的staged特性，可以提取出本次提交的变动文件，让prettier只处理这些文件。 1、配置 npm 脚本命令在项目的package.json中，配置pre-commit的hook任务： 12345678910111213141516171819&#123; "scripts": &#123; "precommit": "lint-staged", "lint-staged:es": "eslint --fix -c .eslintrc", "lint-staged:style": "stylelint --syntax less", &#125;, "lint-staged": &#123; "src/**/*.&#123;js,jsx&#125;": [ "format", "lint-stagted:es", "git add" ], "src/**/*.less": [ "format", "lint-staged:style", "git add" ] &#125;,&#125; 至此，你的项目就可以支持自动检查和格式化了。即使团队中有人没有安装三种代码分析工具，也可以确保他的代码在提交到项目仓库中时，总是被检查修改和格式化了之后。 六、在编辑器配置ESLint、Prettier 和 StyleLint上一部分说到在项目中集成了ESLint、Prettier 和 StyleLint三种代码分析工具， 但每一次还是要手动运行命令。如何能与编辑器（IDE)结合起来呢？以 WebStrom 为例： 1、在 WebStorm开启 ESLint在 WebStorm 中，打开设置（File&gt;Setting或者Alt+F7），按路径进入 ESLint 的配置界面（Languages&amp;Frameworks&gt;JavaScript&gt;Code Quality Tools&gt;ESLint）。开启 ESLint，并配置相应路径，配置文件默认使用.eslintrc。 2、在 WebStorm开启 Prettier在macOS 上快捷键：Alt-Shift-Cmd-P； 在Windows and Linux上快捷键：Alt-Shift-Ctrl-P，可以用 Prettier格式化选中代码、整个文件或目录。 3、在 WebStorm开启 StyleLintWebStorm天然支持stylelint。打开配置() Languages &amp; FromeWorks &gt; StyleSheets &gt; Stylelint)只需在里面开启并配置安装包path即可。 六、总结在使用上述三种代码分析工具后， 代码风格保持一致， 不用再为非业务逻辑代码而争吵， 提高工作效率。由于篇幅问题， 很多东西没有展开描述，可自行查询相关资料。]]></content>
      <tags>
        <tag>React</tag>
        <tag>ESLint</tag>
        <tag>Prettier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG入门与实践]]></title>
    <url>%2F2018%2F05%2F19%2FSVG%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[今天来聊聊SVG技术。本文先简单阐述svg的概念和一些特性， 再分享一些我在项目实战中用到的svg例子。 一、入门概念Scalable Vector Graphics (SVG) 可扩展矢量绘图，是一种用来描述二维矢量图形的XML标记语言。 特性SVG 可被非常多的工具读取和修改（比如记事本）SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。SVG 是可伸缩的SVG 图像可在任何的分辨率下被高质量地打印SVG 可在图像质量不下降的情况下被放大SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）SVG 可以与 Java 技术一起运行SVG 是开放的标准SVG 文件是纯粹的 XMLSVG 的主要竞争者是 Flash。与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术。 基础形状矩形 &lt;rect&gt;圆形 &lt;circle&gt;椭圆 &lt;ellipse&gt;线 &lt;line&gt;折线 &lt;polyline&gt;多边形 &lt;polygon&gt;路径 &lt;path&gt; 使用方式 将SVG文件作为图片，与普通图片使用方式一致；但不会加载自身引用， 如字体、图标等等外部资源。 将SVG作为应用程序，SVG文件也可以作为&lt;object&gt;元素的data属性引入HTML中。但是，MIME type必须是image/svg+xml。 混合文档, 直接跟HTML标签混合写入， 会继承父文档的样式，默认以inline方式显示。 使用总结在我实际使用svg的过程中， 除了path， 我觉得实现起来都不会太难。 path的可以用于十分复杂的场景，也十分灵活， 但学习曲线比较陡。接下来就一起看看path的一些实践例子。 二、实践svg实现波浪、水泡效果先上效果图 实现代码(Reactjs中)1、波浪的实现创建单个波浪的svg,wave.svg(以下css的背景图引用) ， 主要使用path的C指令绘制3次贝塞尔曲线， 其他指令可查阅svg教程。 12345678910&lt;svg xmlns="http://www.w3.org/2000/svg" width="1600" height="698"&gt; &lt;defs&gt; &lt;linearGradient id="a" x1="50%" x2="50%" y1="-10.959%" y2="100%"&gt; &lt;stop stop-color="#ffffff" stop-opacity=".25" offset="0%"/&gt; &lt;stop stop-color="#ffffff" offset="100%"/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;path fill="url(#a)" fill-rule="evenodd" d="M.005 121C311 121 409.898-.25 811 0c400 0 500 121 789 121v77H0s.005-48 .005-77z" transform="matrix(-1 0 0 1 1600 0)"/&gt;&lt;/svg&gt; 创建4个div 123456&lt;div className="ocean"&gt; &lt;div className="wave"&gt;&lt;/div&gt; &lt;div className="wave"&gt;&lt;/div&gt; &lt;div className="wave"&gt;&lt;/div&gt; &lt;div className="wave"&gt;&lt;/div&gt;&lt;/div&gt; 编写样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.ocean &#123; opacity: .4; height: 320px; width: 100%; position: absolute; bottom: 0; left: 0; z-index: 1;&#125;.wave &#123; background: url('../../assets/login/svg/wave.svg') repeat-x; position: absolute; top: 119px; width: 12800px; height: 318px; animation: wave 4.6s cubic-bezier(0.36, 0.45, 0.63, 0.53) -.125s infinite; transform: translate3d(220, 110, 0); opacity: 1;&#125;.wave:nth-of-type(2) &#123; top: 125px; animation: wave 5.5s cubic-bezier(0.36, 0.45, 0.63, 0.53) -.125s infinite; opacity: .6;&#125;.wave:nth-of-type(3) &#123; top: 130px; animation: wave 7s cubic-bezier(0.36, 0.45, 0.63, 0.53) -.125s infinite; opacity: .4;&#125;.wave:nth-of-type(4) &#123; top: 135px; animation: wave 6s cubic-bezier(0.36, 0.45, 0.63, 0.53) infinite; /* animation: wave 6s cubic-bezier(0.36, 0.45, 0.63, 0.53) -.125s infinite, swell 7s ease -1.15s infinite;*/ opacity: .3;&#125;@keyframes wave &#123; 0% &#123; margin-left: 0; &#125; 100% &#123; margin-left: -1600px; &#125;&#125;@keyframes swell &#123; 0%, 100% &#123; transform: translate3d(0, -115px, 0); &#125; 50% &#123; transform: translate3d(0, 5px, 0); &#125;&#125; 设定每个div的位置和动画， 动画wave表示波浪的作用位置，而且无限循环，动画swell表示波浪的变换。就是如此简单！ 2、水泡的实现 创建单个水泡（ES6） 123456789101112131415161718192021//单个水泡createPop = (i) =&gt; &#123; let bottom = Math.round(Math.random() * 100).toFixed(2); bottom = bottom &gt; 55 ? 55 : bottom; let left = Math.round(Math.random() * 100).toFixed(2); let second = Math.random() * 10; return ( &lt;svg width="8px" height="8px" version="1.1" id=&#123;`login-pop$&#123;i&#125;`&#125; style=&#123;&#123; position: 'absolute', bottom: `$&#123;bottom&#125;%`, left: `$&#123;left&#125;%`, animation: ` popup $&#123;second&#125;s cubic-bezier(0.36, 0.45, 0.63, 0.53) -.125s infinite` &#125;&#125; xmlns="http://www.w3.org/2000/svg"&gt; &lt;circle cx='4px' cy='4px' r="4" fill='rgba(255,255,255,0.2)'/&gt; &lt;/svg&gt; ); &#125;; 创建svg画布，大小8，使用&lt;circle&gt;创建圆，半径是4。内联样式，规定布局位置是: absolute, 具体坐标是随机生成的，再加入动画，无限循环。 创建多个水泡 123456789101112//生成指定个数的随机位置水泡createRandomPops = () =&gt; &#123; let arr = []; for (let i = 0; i &lt; 40; i++) &#123; arr.push(i); &#125; return arr.map((s, i) =&gt; &#123; return &lt;div key=&#123;i&#125;&gt; &#123;this.createPop(i)&#125; &lt;/div&gt;; &#125;);&#125;; 在Reactjs的渲染中调用 1&#123;this.createRandomPops()&#125; 水泡的样式 12345678@keyframes popup &#123; 0%&#123; bottom: 16% &#125; 100%&#123; bottom: 55%; &#125;&#125; 水泡只需要向上冒即可，开始从底部16%的位置， 终止位置大约在页面中间，无限循环。 svg实现渐变进度条效果图 图中的进度条是由左右两个半圆组合而成。 代码实现（Reactjs）绘制扇形 123456789101112131415161718192021222324252627282930313233343536373839404142 /** * 扇形绘图方法,计算终点的 x,y 坐标 * * @param Number progr 进度值， 小于100的整数 * @param String direction 左半圆还是有半圆 * @param cx, cy, r默认的x、y坐标， r是半径 * @return 返回path中d指令参数 */sector = (progr = 0, direction = 'right', cy = 63, cx = 220, r = 156) =&gt; &#123; let progress = progr &gt; 100 ? 100 : (progr &lt; 0 ? 0 : progr); // 计算当前的进度对应的角度值 const degrees = progress * (360 / 100); // 计算当前角度对应的弧度值 let rad = degrees * (2 * Math.PI / 360); let startY = cy; let x2 = cx, //结束X点 y2 = cy; //结束Y点 // sweepFlag 1 顺时针，0逆时针 if (direction === 'right') &#123; //右边圆环 if (progress &gt; 50) &#123; //多于50%，右边圆环满进度 x2 = cx; y2 = startY + r * 2; &#125; else &#123; x2 = cx + r * Math.sin(rad);//计算x轴 y2 = startY + r - r * Math.cos(rad);//计算y轴 &#125; &#125; else &#123; //左边圆环 //需要100-progress if (progress &gt; 50) &#123; const leftRad = (100 - progress) * (360 / 100) * (2 * Math.PI / 360); //console.log(leftRad,811) startY = startY + r * 2; x2 = cx - r * Math.sin(leftRad);//计算x轴 y2 = startY - r - r * Math.cos(leftRad);//计算y轴 &#125; &#125; return ['M', cx, startY, 'A', r, r, 0, 0, 1, x2.toFixed(0), y2.toFixed(0)];&#125;; 关键点：由于是动态的进度，x、y的值必须是动态计算，这里包含是数学知识是：在圆中根据角度计算坐标值。M指令是移动光标到初始位置的坐标， A指令是绘制一条曲线。 在React中定义svg 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div className="progress-wrap"&gt; &lt;svg width="160" height="160" viewBox="0 0 440 440" className="center"&gt; &lt;defs&gt; &lt;linearGradient x1="0" y1="0" x2="1" y2="1" id=&#123;'left' + idx&#125;&gt; &lt;stop offset="100%" style=&#123;&#123;stopColor: colors.max&#125;&#125;&gt;&lt;/stop&gt; &lt;stop offset="0%" style=&#123;&#123;stopColor: colors.middle&#125;&#125;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="1" y1="1" x2="0" y2="0" id=&#123;'right' + idx&#125;&gt; &lt;stop offset="0%" style=&#123;&#123;stopColor: colors.mini&#125;&#125;&gt;&lt;/stop&gt; &lt;stop offset="100%" style=&#123;&#123;stopColor: colors.max&#125;&#125;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;filter id="f1" x="0" y="0" height="200%" width="200%"&gt; &lt;feOffset result="offOut" in="SourceAlpha" dx="4" dy="4"/&gt; &lt;feGaussianBlur result="blurOut" in="offOut" stdDeviation="8"/&gt; &lt;feBlend in="SourceGraphic" in2="blurOut" mode="normal"/&gt; &lt;/filter&gt; &lt;linearGradient id=&#123;'right-' + idx&#125; gradientUnits="userSpaceOnUse" x1="220" y1="60" x2="220" y2="375"&gt; &lt;stop offset="0" style=&#123;&#123;stopColor: colors.mini&#125;&#125;&gt;&lt;/stop&gt; &lt;stop offset="1" style=&#123;&#123;stopColor: colors.middle&#125;&#125;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient id=&#123;'left-' + idx&#125; gradientUnits="userSpaceOnUse" x1="0" y1="60" x2="0" y2="375"&gt; &lt;stop offset="0" style=&#123;&#123;stopColor: colors.max&#125;&#125;&gt;&lt;/stop&gt; &lt;stop offset="1" style=&#123;&#123;stopColor: colors.middle&#125;&#125;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;g&gt; /* 进度条的底色 */ &lt;circle cx="220" cy="220" r="160" strokeWidth="50" stroke="#e5e8f8" fill="none" strokeDasharray="1005 1005"&gt;&lt;/circle&gt; &lt;path d=&#123;`$&#123;this.sector(percent).join(' ')&#125;`&#125; stroke=&#123;`url('#right-$&#123;idx&#125;')`&#125; fill="none" strokeWidth="40"&gt;&lt;/path&gt; &#123;percent &gt; 50 &amp;&amp; &lt;path d=&#123;`$&#123;this.sector(percent, 'left').join(' ')&#125;`&#125; stroke=&#123;`url('#left-$&#123;idx&#125;')`&#125; fill="none" strokeWidth="40"&gt;&lt;/path&gt;&#125; &lt;circle cx="220" cy="220" r="197" strokeWidth="40" stroke="#f5f6fa" fill="none" strokeDasharray="1256 1256"&gt;&lt;/circle&gt; &lt;/g&gt; &lt;/svg&gt; &lt;p className="percent-text " style=&#123;&#123;color: colors.max&#125;&#125;&gt; &lt;span className=&#123;'percent-number'&#125;&gt; &#123;percent&#125; &lt;/span&gt; &lt;span className=&#123;'percent-symbol'&#125;&gt; % &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; linearGradient是表示创建渐变； g中的circle表示进度条的底色和外部包裹圆环；当进度大于50%时才创建左半圆，边框的宽度都是40px； colors是预定义的几种颜色，用于渐变 ：const colors = {max: &#39;#3cc8bc&#39;, middle: &#39;#27aea3&#39;, mini: &#39;#9eece7&#39;}； 百分比显示在圆环中间。 总结本文通过两个简单例子展示svg的强大之处。总的来说，svg不难， 只是涉及的知识比较多， 多实践，就熟练了。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建前端异常监控系统]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[最近公司的业务系统和几个对外应用Web端进入了最后测试阶段，随之带来的问题是每次出现问题都要测试人员主动联系我们开发者，但有时又无法重现， 既浪费时间， 又无法及时有效解决异常。因此，我觉得搭建一个前端异常监控系统， 用来实时收集前端异常， 及时解决前端异常。 一、开源监控服务的优劣在日常的工作中，我们在开发某个功能或者应用之前， 都会先搜寻一下是否有相似的开源项目，以此来提高开发效率。在前端监控系统这类项目中， 我比较喜欢Sentry这个项目： 1、功能齐全，包括多项目管理， 团队与成员的管理，可视化统计分析，issues分配等等。2、SDK丰富， 包括了JavaScript， Nodejs， Java等等收集工具。3、可以采用Docker安装，容器化管理数据。4、项目一直在维护更新。但功能齐全的背后带来的问题就是，每个公司都会有客制化的需求， 而要想在如此庞大的项目中二次开发是十分吃力的。对于我们公司目前的开发力量开始， 暂时无法分配人员专门客制化Sentry。 二、收集日志的方法收集日志的手段，基本是两种，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如try..catch 和 window.onerror。 1 上报Ajax请求错误就公司目前的开发栈来说， 前后端通讯都是依靠rest api，尤其在使用React这种前端框架后， 在axios的请求中会出现无法预料的错误与异常。那么此时我们需要主动调用日志上报工具收集错误并发给监控系统。 在axios的响应拦截中(示例)： 123456789101112131415161718//响应拦截axios.interceptors.response.use( response =&gt; &#123; return response.data; error =&gt; &#123; appStore.hideLoading(); Reporter.send(&#123; &#123; error: error msg: &quot;ajax error&quot; &#125; &#125;) return Promise.reject(error); &#125;); 2、使用try..catch捕获判断某个函数或某段代码里存在错误： 123456try &#123; fetch(); &#125; catch(e)&#123; Reporter.send(e);&#125; 在React应用中， 可以使用组件的 componentOnCatch来捕获该组件内所有错误 3、window.onerror捕获全局错误 12345window.onerror = () =&gt; &#123; var errInfo = format(arguments); Reporter.send(errInfo); return true;&#125;; 在上面的函数中返回 return true，控制台不会输出错误信息。下面是它的参数信息： 12345678910/** * @param &#123;String&#125; errorMessage 错误信息 * @param &#123;String&#125; scriptURI 出错的文件 * @param &#123;Long&#125; lineNumber 出错代码的行号 * @param &#123;Long&#125; columnNumber 出错代码的列号 * @param &#123;Object&#125; errorObj 错误的详细信息，Anything */window.onerror = function(errorMessage, scriptURI, lineNumber,columnNumber,errorObj) &#123; // code..&#125; 三、前端上报异常的坑1、无具体报错信息，Script error.在日常开发中我们会医用一些第三方库， 当这些库在我们的应用中出现异常时， 由于浏览器的安全限制，我们无法捕获到具体的错误和错误位置，目的是避免数据泄露到不安全的域中。 2、 异常上报跨域限制这也是由于浏览器的同源策略， 不予对非同源的资源进行操作。但通常异常监控系统与目标应用都是不同源， 这就涉及到一个跨域问题了。在React的开发中，若使用rest api进行通讯， 也需要配置反向代理才能进行Ajax请求。 那我们该如何在异常上报中打破跨域的限制呢？ 在上报的HTTP的投中加入 header(&#39;Access-Control-Allow-Origin: *&#39;) 同样，在服务中也需要设置 Access-Control-Allow-Origin的响应头。 3、压缩代码无法定位到错误位置。在我们的日常开发中，我们使用Debug可以定位到代码错误的哪一行哪一列。但在生产环境中的代码通常是经过压缩的，按照正常debug方法， 显示的错误位置都是第一行。那么我们如何解决呢？ 第一个想到的办法是利用 sourceMap，利用它可以定位到压缩代码某一点在未压缩代码的具体位置。下面是 sourceMap 引入的格式，在代码的最后一行加入： 1//# sourceMappingURL=index.js.map 4、切勿重复注册error事件在以前的前端应用中，很容易出现这个问题。在React这种单页面应用， 我们只需要在应用的入口处注册我们的error事件即可。保证error事件只被注册一次， 以免漏掉错误发生点。 5、异常上报频率我们当然希望把所有的错误上上报到监控系统中， 但一旦应用十分庞大时， 上报的频率会非常大， 在一定程度上会影响前端应用的性能。这个只能根据实际项目去衡量得失了。 四、设计监控系统对于前端开发人员来说， 最熟悉的还是Nodejs了。因此我们决定使用Nodejs搭建一个简单的异常收集与监控系统。 1、数据库设计在数据库想选择上当然是MongoDB了 ， 适合存储格式不统一的日志文本。 创建四个文档： ####（1）user 用于存储监控系统的用户和角色等控制。 (2) bug 用于存储前端上报的错误与异常。(3) project 目前来说我们的有不止一个的前端项目， 所有监控系统需要支持多项目管理， 存储不同的项目的上报KEY，用于统计和分析。(4) ajax 用于ajax请求中上报的错误， ajax的错误或许会很多， 而且错误格式与window.error不一致， 所以将两者分开存储。剩下的就是各个文档中的字段设计了， 这里就不赘述了。 2、系统架构设计 config 用于一些系统配置 controllers 用于系统控制器，接受http请求被返回处理后的结果 lib 用于系统函数和工具函数 models 用于数据模型的定于与设计 router 用于系统的路由定义 services 用于封装数据库的查询服务 app.js 是整个Nodejs系统的入口，启动http服务和连接数据库等等。 3、reast api设计在rest通讯中最重要的一点就是使用token进行用户的认证与授权（JWT）， 我在这里使用的是jsonwebtoken 在控制器的方法中定义http的请求的类型、参数和响应体，总体难度不大， 根据项目实际需求来设计。 五、 最后到目前为止我们的简单异常监控系统初具雏形了，剩下的就是如何填充血肉了。在整个系统的设计中还是学到不少知识， 有些东西因为时间久了，有些遗忘，不得不去重新学习。因此，作为一个开发者， 最重要的还是要时刻保持求贤若渴的心态许学习心知识和温故旧知识。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建企业内部React组件库]]></title>
    <url>%2F2018%2F03%2F24%2F%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8React%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近针对日常业务需求使用react封装了一套基于 ant-design 的[业务组件库], 大概记录下整个开发过程中的心得，在这里只对开发过程中的选型和打包等进行讨论，后续再对具体组件的封装进行讨论。 概述随着公司的 React 应用越来越多， 在编写每个应用时都会封装各自的组件， 但久而久之会发现， 有些组件是每个应用都可以使用的。 然而，在每个应用内维护相同的功能组件， 既浪费时间， 组件功能和样式又得不到同步。于是我就在想能不能把这些通用组件抽取出来， 创建一个企业内部的业务组件库， 打包发布到 npm 内部管理服务器。 由于目前公司采用的组件库是 ant-design ，本次的内部组件库是对 ant-design 的二次封装，以便满足公司的业务。虽然 antd-pro是基于 ant-desgin 的中后台业务组件库， 但也无法完全满足公司的业务逻辑， 所以还是自己做一些功夫， 定制自己业务组件库，暂且命名为 hx-react-components 搭建 npm 私服npm 私服有几个选择： sinopia 已停止维护和升级 Verdaccio 一个sinopia的fork 这里我采用 Verdaccio 搭建 npm 私服。安装教程可参考官方教程。使用也很简单： 启动 verdaccio,不要用 root 启动，会引发不可控错误。 设置服务访问路径，默认只能本地访问 npm set registry http://ip:4873/ 添加用户 npm adduser --registry http://ip:4873 发布我们的包 npm publish --registry http://ip:4873 就是如此简单！ 技术选型技术方案选择Webpack + React 毫无疑问的选择 React 进行业务组件定制。 1、应用初始化使用 create-react-app进行初始化， 无须过多的配置。 2、引入 ant-design具体方法参考 ant-desgin 的官方教程。 3、样式预编译语言由于该组件库大多是业务逻辑组件， 暂且不考虑 Less 其他样式预编译语言。后期再考虑。所以依然采用 CSS 进行部分样式描绘。 开发流程和规范由于该组件库是完全独立于其他任何 React 项目， 而且不需要编写页面， 因此需要有特有的开发流程和架构。主要有一下几点： 包含开发、测试和打包三种模式。 使用pure-render，autobind等尽可能保证组件的性能及效率 保证props和回调的语义性，如回调统一使用onXXX进行处理 针对不同的模式， 配置不同的 webpack脚本： 123456789101112131415 "test": "react-scripts test --env=jsdom",//测试"styleguide": "styleguidist server", //文档开发"styleguide:build": "styleguidist build", //文档大伯"styleguide:deploy": "scp -r styleguide/* root@192.168.1.x:/var/www/styleguide",//文档部署，供公司人员查看"predeploy": "npm run styleguide:build",//预处理文档部署"build": "babel src -d lib",//组件库打包"lint": "eslint src/components/**; exit 0",//组件库规范检查"lint:watch": "esw -w src/**",//规范监控"prepublish": "npm run build",//预发布"push": "git push origin &amp;&amp; git push origin --tags",//推送远程仓库"release:patch": "npm version patch &amp;&amp; npm publish --registry=http://192.168.1.x",// 兼容版本发布到 Verdaccio"release:minor": "npm version minor &amp;&amp; npm publish --registry=http://192.168.1.x",// 小版本发布到 Verdaccio"release:major": "npm version major &amp;&amp; npm publish --registry=http://192.168.1.x"// 大版本发布到 Verdaccio 打包webpack 配置针对组件库的打包，我们以UMD格式对其进行打包。webpack可以针对输出进行格式设置：（引自cnode) “var” 以变量方式输出 “this” 以 this 的一个属性输出： this[“Library”] = xxx； “commonjs” 以 exports 的一个属性输出：exports[“Library”] = xxx； “commonjs2” 以 module.exports 形式输出：module.exports = xxx； “amd” 以 AMD 格式输出； “umd” 同时以 AMD、CommonJS2 和全局属性形式输出。 配置如下： 12345678output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].js'), chunkFilename: utils.assetsPath('js/[id].js'), library: 'TipUi', libraryTarget: 'umd'&#125; 注意： 这里不应该把React引用进去。一般我们可以采用externals的方式对其进行处理。 文档示例开发组件库不同于页面开发， 可以配置路由来预览我们的开发。 一个完善的文档对于一个组件库是及其重要的，每个组件有什么样的配置参数，拥有哪些事件回调，对应的Demo和展示效果。假设没有这些，除了封装组件的人，没有人知道它该如何使用。但是写文档的过程往往是痛苦的，在这里推荐几个文档生成库，可以极大的简化文档工作： docsify 基于Vue的组件生成器，轻量好用 react-styleguidist 基于React的组件库文档生成器，自动根据注释生成文档，支持Demo展示。超好用 bisheng ant design自己写的文档生成器 我们使用的styleguidist, 可以将md自动转化为文档，支持在md内直接调用你封装好的组件并进行展示，简单好用 组件库使用在我们的项目里， 其他的依赖包是从 npm 官网拉取， 但我们的x-react-components 是走npm 私服 - verdaccio， 那如何写package.json 的 x-react-components 依赖路径呢？ 目前我们是这样写： 12"x-react-components":"http://ip:4873/x-react-components/-/0.1.15.tar.gz" 这样写的缺点就是每次手动改版本号， 后续会考虑采用 dll检查组件库的更新状况。 每次 react 应用打包前检查 x-react-components 是否有更新。有， 先更新组件库， 再打包； 否则， 直接打包。 最后本文概述了如何构建 npm 私服、开发自己的业务组件库。篇幅有限， 可能很多细节没有描述清楚， 但这大致是我在公司搭建的内部react 组件 库的过程。]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端预览PDF那些事]]></title>
    <url>%2F2018%2F03%2F10%2F%E5%89%8D%E7%AB%AFPDF%E9%A2%84%E8%A7%88%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近项目中需要在网页上预览 PDF，目前了解到 有&lt;iframe&gt;、&lt;object&gt;、&lt;embed&gt;标签 和 pdf.js、pdfObject等几种第三方解决方案， 但还有一些注意事项。 一、&lt;iframe&gt; 预览 PDF在 PDF 预览中&lt;iframe&gt;算是一种古老但高效的解决方案。现在所有浏览器都支持 &lt; iframe &gt; 标签，直接将src设置为指定的PDF文件就可以预览了。src可以是url、bolb 或者 base64,一切问题都容易解决， 关键是要标记 资源类型type=“application/pdf” 二、&lt;embed&gt;预览 PDF&lt; embed &gt;标签定义嵌入的内容，比如插件。但是这个标签没有提供回退方案，与&lt; iframe &gt; &lt; / iframe &gt;不同，这个标签是自闭合的的，也就是说如果浏览器不支持PDF的嵌入，那么这个标签的内容什么都看不到，经测试在 Safari 下无法预览。用法如下： 12&lt;embed src="/my.pdf" type="application/pdf" width="100%" height="100%"&gt; 三、&lt;object&gt;预览 PDF&lt; object &gt;定义了一个嵌入的对象，可以使用此元素向页面添加多媒体。该元素允许您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。几乎所有主流浏览器都拥有部分对 &lt; object &gt;标签的支持。这个标签在这里的用法和&lt; iframe &gt;很类似，也支持回退；还可以和&lt;iframe&gt;结合使用， 为我们提供更强大的回退方案。 以上的标签都是无需 JavaScript 支持的 PDF 预览方案， 接下来谈谈 JS 库下的 pdf 预览方案。 四、pdf.js 预览 PDFPDF.js可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件，非常强大，能将PDF文件渲染成Canvas。PDF.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。 由于我是在 React 下使用该库， 因此使用了 react-pdf-js 这个react 组件实现 pdf.js相同的效果。 具体用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React from &apos;react&apos;;import PDF from &apos;react-pdf-js&apos;;class MyPdfViewer extends React.Component &#123; state = &#123;&#125;; onDocumentComplete = (pages) =&gt; &#123; this.setState(&#123; page: 1, pages &#125;); &#125; onPageComplete = (page) =&gt; &#123; this.setState(&#123; page &#125;); &#125; handlePrevious = () =&gt; &#123; this.setState(&#123; page: this.state.page - 1 &#125;); &#125; handleNext = () =&gt; &#123; this.setState(&#123; page: this.state.page + 1 &#125;); &#125; renderPagination = (page, pages) =&gt; &#123; let previousButton = &lt;li className=&quot;previous&quot; onClick=&#123;this.handlePrevious&#125;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i className=&quot;fa fa-arrow-left&quot;&gt;&lt;/i&gt; Previous&lt;/a&gt;&lt;/li&gt;; if (page === 1) &#123; previousButton = &lt;li className=&quot;previous disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i className=&quot;fa fa-arrow-left&quot;&gt;&lt;/i&gt; Previous&lt;/a&gt;&lt;/li&gt;; &#125; let nextButton = &lt;li className=&quot;next&quot; onClick=&#123;this.handleNext&#125;&gt;&lt;a href=&quot;#&quot;&gt;Next &lt;i className=&quot;fa fa-arrow-right&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;; if (page === pages) &#123; nextButton = &lt;li className=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Next &lt;i className=&quot;fa fa-arrow-right&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;; &#125; return ( &lt;nav&gt; &lt;ul className=&quot;pager&quot;&gt; &#123;previousButton&#125; &#123;nextButton&#125; &lt;/ul&gt; &lt;/nav&gt; ); &#125; render() &#123; let pagination = null; if (this.state.pages) &#123; pagination = this.renderPagination(this.state.page, this.state.pages); &#125; return ( &lt;div&gt; &lt;PDF file=&quot;somefile.pdf&quot; onDocumentComplete=&#123;this.onDocumentComplete&#125; onPageComplete=&#123;this.onPageComplete&#125; page=&#123;this.state.page&#125; /&gt; &#123;pagination&#125; &lt;/div&gt; ) &#125;&#125;module.exports = MyPdfViewer; 在实际使用中， 效果确实不错， 还提供 webworker 来实现分页渲染，但因为我目前的项目是要预览含有电子签章的 PDF 文件，在测试中发现，pdf.js 并不支持该特性，若要显示电子签章， 需要在源文件中更改一些地方， 故此我在项目中放弃使用 pdf.js 五、pdfObject看官网上的介绍，PDFObject并不是一个PDF渲染工具，它也是通过&lt; embed &gt;标签实现PDF预览。PDFObject提供了一个PDFObject.supportsPDFs用于判断该浏览器能否使用PDFObject。 12345if(PDFObject.supportsPDFs)&#123; console.log("Yay, this browser supports inline PDFs.");&#125; else &#123; console.log("Boo, inline PDFs are not supported by this browser");&#125; 这个库我是最近才了解到，本打算看看如何隐藏&lt;iframe&gt;预览的 pdf 中的工具栏， 无意中发现该方案，目前尚未尝试，基本用法也很简单: 123456789&lt;script type="text/javascript"&gt; if(PDFObject.supportsPDFs)&#123; // PDF嵌入到网页 PDFObject.embed("index.pdf", "#pdf_viewer" ); &#125; else &#123; location.href = "/canvas"; &#125;&lt;/script&gt; 六、结尾总的来说，pdf 预览的方案挺多选择的， 适合自己项目的才是最好。 像我的需求是要显示电子签章， 验证多种方案后选择使用 iframe 标签显示。当然你也可以再后端把 pdf 文件转换成图片传回前端显示。]]></content>
      <tags>
        <tag>PDF</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个美剧自动嗅探下载器:TVDragon(下)]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%BE%8E%E5%89%A7%E8%87%AA%E5%8A%A8%E5%97%85%E6%8E%A2%E4%B8%8B%E8%BD%BD%E5%99%A8-TVDragon-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[通过上篇的准备工作， 我们基本掌握整个爬虫的工作流程。接下来我们就要实现该爬虫系统了。在程序语言上有了改动， 因为最近基本是 JavaScript开发， 所以我们采用 Nodejs 作为开发语言， 而不是 PHP。毕竟， 一个程序的好坏跟程序语言没有必然联系。 一、搭建框架1、使用 package.json初始化。2、构建目录结构，目前的目录结构如图。 解释： src dev.js spider.js index.js根据部署环境调用不同文件作为入口。 config 数据库和 程序参数等基本设置 constants 一些种子网站列表和 api 等定义。 core核心的爬虫类， 定义播放表获取、下 html 代码 html解析类和 transmissiorpc 连接类等核心类库。 storage 数据库 Schema 定义和 CRUD 的基本服务类。 3、定义 Mongoose Schema这里我们使用 Mongoose 来操作MongoDB，首先需要定义Schema。 1、 播放表 Schema，用了存储从字幕组 APP 获取的美剧播放表。 1234567891011121314151617181920212223242526import mongoose from 'mongoose'const Schema = mongoose.Schemaconst SeriesSchema = new Schema( &#123; id: &#123;type: Number, required: true&#125;, cnname: &#123;type: String, required: true&#125;, enname: &#123;type: String, required: true&#125;, poster: String , season: &#123;type: Number, required: true&#125;, episode: &#123;type: Number, required: true&#125;, play_time: &#123;type: String, required: true&#125;, poster_a: String, poster_b: String, poster_m: String, poster_s: String, status: &#123; type: Number, required: true, default: 1000 &#125;, created_at: &#123;type: Date, default: Date.now&#125;, updated_at: &#123;type: Date, default: Date.now&#125; &#125;, &#123; collection: 'series' &#125;)export default mongoose.model('series', SeriesSchema) 2、种子 Schema,用来存储从种子网站爬取解析得到的 torrent 列表。 12345678910111213141516171819202122import mongoose from 'mongoose'const Schema = mongoose.Schemaconst TorrentSchema = new Schema( &#123; series_id: &#123;type: Number, required: true&#125;, torrent_name: String, hash: String, url: String, size: String, seeds:Number,//种子数 downloaded: &#123;type: Boolean, required: true, default: false&#125;, status: &#123; type: Number, required: true, default: 1000 &#125;, created_time: &#123;type: Date, default: Date.now&#125;, updated_time: &#123;type: Date, default: Date.now&#125; &#125;, &#123; collection: 'torrent' &#125;)export default mongoose.model('torrent', TorrentSchema) 4、爬取美剧播放表信息（根据当天日期），持久化存储到 MongoDB关键代码： 123456789101112131415161718192021222324252627282930313233 fetchSchedule (startDate, endDate) &#123; const queryStr = &#123; accesskey:'e519f9cajd7qc8059d175449479u61a827', client:1, g:'api/v2', m:'index', a:'tv_schedule', start: startDate, end: endDate &#125;; const options = &#123; url: RR_PLAY_SCHEDULE, method: "get", qs: queryStr, headers: &#123; 'User-Agent': UserAgent[0] &#125; &#125;; return new Promise((resolve, reject) =&gt; &#123; request(options, (error, response, body) =&gt; &#123; if (!error &amp;&amp; response.statusCode === 200) &#123; const info = JSON.parse(body); return resolve(info) &#125; else &#123; return reject(error) &#125; &#125;) &#125;)&#125; 5、使用 Pupeteer 下载 html 源码。Puppeteer是谷歌官方出品的一个通过DevTools协议控制headless Chrome的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。 Puppeteer的使用十分简单，通过操作Browser实例来操作浏览器作出相应的反应。 此处使用Puppeteer下载 html页面的关键代码： 12345678910111213141516171819puppeteerDownloadHTML () &#123; return new Promise(async (resolve, reject) =&gt; &#123; try &#123; const browser = await puppeteer.launch(&#123; headless: true, ignoreHTTPSErrors: true, &#125;) const page = await browser.newPage() await page.setCookie(this.cookie) await page.goto(this.url) const bodyHandle = await page.$('body') const bodyHTML = await page.evaluate(body =&gt; body.innerHTML, bodyHandle) return resolve(bodyHTML) &#125; catch (err) &#123; console.log(err) return reject(err) &#125; &#125;)&#125; 6、使用 cheerio 从 html 文本中解析数据。cheerio是一个node的库，可以理解为一个Node.js版本的jquery，用来从网页中以 css selector取数据，使用方式和jquery基本相同。事实上，Cheerio 从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分，性能更优。 前面我们已经使用 Pupeteer 下载了 html 源码， 我们将提取我们需要的数据列表，然后持久化到 mongodb 中。 关键代码 12345678910111213141516171819torrentz2HubExtract() &#123; let nodeList = this.$('#wrap').find('.results').find('dl') nodeList.each((i, e) =&gt; &#123; let a = this.$(e).find('a'); const hash = a.attr('href')?a.attr('href').replace('/', ''):a.attr('href'); const seeds = this.$(e).find('dd').find('span').eq(3).text() this.extractData.push( this.extractDataFactory( 'http://itorrents.org/torrent/' + hash.toUpperCase() + '.torrent', a.text(), seeds, hash, ) ) &#125;) return this.extractData &#125; 当然每个网站的页面结构不一致， 对不同的站点，我们需要不同解析模式，但使用 cheerio 让这项工作变的超级简单。7、使用 TransmissionRPC 进行 torrent 上传及资源下载。这里我们采用 transmission-promise 进行 transmission 接口调用。根据其文档，我们很容易实现一个自己的 rpc 类库。 这里就不贴代码了， 与文档的例子差不多。 8、cron定时作业爬虫的意义之一就是能定时自动化爬取目标数据。 关键代码 1234567891011121314151617181920212223/!** * # ┌────────────── second (optional) * # │ ┌──────────── minute * # │ │ ┌────────── hour * # │ │ │ ┌──────── day of month * # │ │ │ │ ┌────── month * # │ │ │ │ │ ┌──── day of week * # │ │ │ │ │ │ * # │ │ │ │ │ │ * # * * * * * * *!/function job () &#123; let cronJob = new cron.CronJob(&#123; cronTime: cronConfig.cronTime, onTick: () =&gt; &#123; spider() &#125;, start: false &#125;) cronJob.start()&#125;job() 每天定时跑一遍上述的流程即可。 二、后记目前 TVDragon 还在开发中， 平时时间不是很充裕， 现在基本完成上述模块。 1、需要订阅所追的所有美剧名称，根据订阅的美剧和播放表去搜索 Torrent， 节省耗损。2、搜索的 Torrent 列表可能有多个， 视频的质量参差不齐， 需要一个从优筛选 torrent 的算法。3、 使用日志代替各个 console，针对下仔的信息使用微信公众号模板消息推送， 方便实时跟踪程序运行情况。 4、todo]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个美剧自动嗅探下载器:TVDragon(上)]]></title>
    <url>%2F2017%2F12%2F16%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%BE%8E%E5%89%A7%E8%87%AA%E5%8A%A8%E5%97%85%E6%8E%A2%E4%B8%8B%E8%BD%BD%E5%99%A8-%E4%B8%8A-%2F</url>
    <content type="text"><![CDATA[从今天开始我们来写一个美剧自动嗅探下载器， 名为 TVDragon， 为我们提供美剧‘一条龙服务’。 其工作原理是根据已订阅的美剧名称（英文名），自动搜索当天的美剧播放表， 从种子网站搜索 torrent 列表， 筛选，自动下载该种子，接着上传torrent到树莓派的 transmission 上进行bt下载。 一、背景本人是个美剧爱好者，平时几乎每天都有一部美剧更新，而我每天我要做的事情是上 &lt;zimuzu.tv&gt; 去查看当天的美剧播放表， 然后到&lt;torrentz2.eu&gt;搜索所追美剧的种子， 然后根据清晰度筛选，下载，上传后 transmission 进行资源下载。整个过程虽耗时不长， 但有时当天的美剧有好几部， 而且不一定资源已上传， 这就需要重复上述的步骤了。有时之后就会忘记了， 因此造成晚上下班后才去下载，不能好好的享用“美剧大餐”了。这就是 TVDragon 诞生的背景了。 二、必备条件(材料)若要TVDragon 成功运行， 需要满足以下条件 7x24小时运行的Linux服务器（树莓派） 宽带网络 transmission 软件 PHP7.0+ 三、APi 分析既然我们需要爬取美剧播放表和搜索美剧种子等， 就需要用到Charles这个抓包神器。关于 Charles 的用法可自行搜索，这里不作描述。 1、许多网站都有美剧的播放表，我选择 &lt;zimuzu.tv&gt;上的，而且这里我选用了字幕组IOS非 App Store 版 app作为抓包目标。经分析， App 上面的播放表 api 是https://api1.ousns.net/index.php ,其需要的参数是 123456789&#123; "accesskey": "519f9cab85c8059d17544947k36113fd3g", "client": "1", "g": "api/v2", "m": "index", "a": "tv_schedule", "start": "2017-12-10", "end": "2017-12-11"&#125; 我们这里只需要改变 start 和 end 的值即可获取不同日期的当天美剧播放列表， 但不包含 end 日期的数据 响应内容是123456789101112131415161718192021&#123; "status": 1, "info": "", "data": &#123; "2017-12-24": [ &#123; "id": "35673", "cnname": "谷中十日", "enname": "Ten Days In the Valley", "poster": "http://tu.zmzjstu.com/ftp/2017/1001/88292ec7121c82fd6f432f3509411913.jpg", "season": "1", "episode": "7", "play_time": "2017-12-24", "poster_b": "http://tu.zmzjstu.com/ftp/2017/1001/b_88292ec7121c82fd6f432f3509411913.jpg", "poster_m": "http://tu.zmzjstu.com/ftp/2017/1001/m_88292ec7121c82fd6f432f3509411913.jpg", "poster_s": "http://tu.zmzjstu.com/ftp/2017/1001/s_88292ec7121c82fd6f432f3509411913.jpg" &#125; ] &#125;&#125; status=1 表示请求成功。data 字段里的数据就是我们真正需要的，里面包含了每部美剧的中文名、英文名和剧集数量等等 2、根据美剧英文名搜索 torrent 种子列表。这里选择https://torrentz2.eu/search作为搜索的工具。请求参数很简单： 1234&#123; "f": "the+flash+2014+s04e09", "save": true&#125; f 表示搜索的关键字，关键字中的空格转变为+或 urlEcode ；例如：the flash 2014 s04e09 搜索时变为：the%2Bflash%2B2014%2Bs04e09；save 表示是否开启安全搜索，默认开启。 ##### 返回结果 ![d.png](http://ww4.sinaimg.cn/large/a15b4afegy1fmjw8ki15ij20ya0ba782) 更多的搜索结果可查看 &lt;https://torrentz2.eu/search?f=the%2Bflash%2B2014%2Bs04e09&gt; #### 3、查看可用的 torrent 列表 经过上面的搜索后， 我们可以选择清晰度较高的一个资源查看其可用的 torrent 下载列表。 选择这个资源&lt;The.Flash.2014.S04E09.720p.HDTV.x264-SVA[rarbg]&gt;，之后可以看到如下的 torrent 列表： ![torrent 列表](http://ww4.sinaimg.cn/large/a15b4afegy1fmjwdvfcswj20yv0j50zn) 这里的 torrent 列表可能每一次都不一致的， 因此需要找一个资源列表最多的站点， 对每个站点都分析其下载 torrent 的按钮元素和事件， 方可自动下载 torrent 文件。 `` 这里建议若有 rarbg 站点， 首选这个。大多数情况 rarbg 都会比较快更新资源。 `` 更快捷的方法是：根据搜索列表中的 title 中 hash 值解析出 torrent 的真实地址。 规则： `` http://itorrents.org/torrent/hash 值.torrent `` ### 四、Transmission 远程调用接口 ##### 关于树莓派是什么？如何购买树莓派？如何在树莓派安装 transmission等等问题，可自行摸索。这里假设一切条件就绪。 通过上面的步骤我们已经能够实现自动下载 torrent 文件了。既然这样我们需要把 torrent 文件上传到 Transmission 上进资源下载。&lt;transmission.com&gt;上的文档有说明RPC 的方法， 还推荐了几个比较好的类库。 这里我们使用 PHP 实现的transmission RPC类库, &lt;https://github.com/vohof/transmission&gt;. ### 五、结束 到这里为止， 我们基本分析了TVDragon 的工作流程和梳理如何实现这些需求，关键之处就是如何分析所需要的目标程序， 拆分各个功能需求， 搜索是否已有类似的类库， 这样可减少我们的前期工作量。调研工作已基本结束， 后面的事情就是如何搭建一个开发框架了。这将在下一盘文章中阐述。]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Goutte爬取 IP 代理池]]></title>
    <url>%2F2017%2F11%2F18%2F%E4%BD%BF%E7%94%A8%20Goutte%E7%88%AC%E5%8F%96%E4%BB%A3%E7%90%86%20IP%20%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[最近几乎所有精力都投入到 React 的开发中，可以说对 JS 的理解更深入了， 使用起来也得心应手了。但对于 PHP, 我还是想找点东西捣鼓下的。这次我们就用 PHP 的爬虫框架 Goutte 来爬取多个 代理IP，实现一个简单的自动投票系统， 该系统可以切换 IP，从而避免被封禁。当然，这里只是抛砖引玉， Goutte 的强大之处远不在于此。 一、关于 GoutteGoutte 是一个 PHP 爬虫框架，提供了优雅的 API 进行链接抓取，和解析 HTML 文档。Goutte 主要使用以下 PHP 类库： 页面解析：Symfony 的 BrowserKit ， CssSelector 和 DomCrawler； HTTP 请求： Guzzle 相信各位 PHPer 对Guzzle这个库很熟悉吧，这里不展开讨论了。简单来说， 利用 Goutte 可以快速的爬取和解析 Html、xml 的文档， 得到我们的目标数据。 准备工作 既然 Goutte 是解析 HTML 结构的， 那解析规则必须已经设置好，分析目标网站的 DOM 结构是我们的首要工作。 这里我使用的是https://proxy.coderbusy.com/, 打开该网站， 通过页面我们可以知道， 我们的目标数据（IP 池）是显示在 Table 中， 但究竟这是个怎样的 Table 呢？我们打开网站的开发者工具， 分析其 HTMl 代码：1、 , 这个就是我们的目标表格， 其还定义了类名， 这样我们可以快速定位到此元素了。2、 table 的头部有很多列， 这里是每个 IP 的其他属性， 因为我们的目的不是 IP 的属性， 只需要一个代理 IP和端口， 因此我们关心的是 table 的第一列的 IP 地址和第二列的端口。我们直接查看 table 的主体部分的第一个&lt;td&gt;和第二个&lt;td&gt;。 通过查看源码我们可以知道， 我们的 goute 需要解析的是该页面的class=&#39;table proxy-server-table&#39;的 table 中 tbody 中的第一列和第二列。 正式爬取1、 我们使用 composer 安装 Goutte，然后引入。 12require_once dirname(dirname(__FILE__)).'./vendor/autoload.php';use Goutte\Client; 2、编写爬取函数 1234567891011121314151617181920212223function getProxyIPPool()&#123; $client = new Client(); $ipPoolUrl = &apos;https://proxy.coderbusy.com/&apos;; $crawler = $client-&gt;request(&apos;GET&apos;, $ipPoolUrl); $ipArr = $crawler-&gt;filter(&apos;table&apos;)-&gt;filter(&apos;tr&apos;)-&gt;each(function ($tr, $i) &#123; return $tr-&gt;filter(&apos;td&apos;)-&gt;each(function ($td, $i) &#123; return trim($td-&gt;text()); &#125;); &#125;); $newArr = []; foreach ($ipArr as $key =&gt;$value)&#123; if ($key &gt;0)&#123; $newArr[$key-1] = $value[0].&apos;:&apos;.$value[1];//这里就是 table 的第一列和第二列 &#125; &#125; $file = file_put_contents(&apos;ipPool.json&apos;, json_encode($newArr)); echo &quot;更新代理 IP 尺完毕&quot;;&#125; 这里我们直接把解析出来的数据存储到本地 json 文件中（真正应用时最好存到数据库， 以便用于其他分析用途）。执行完一次后我们得到的 json 文件(仅显示部分数据): 12345[ "13.59.33.106:3128", "200.116.227.99:53281", "190.232.168.242:8080"] 由于该网站每次刷新的时候表格的数据都是不一样，我们既可以存储到不同 json 文件中， 也可以覆盖同一个 json 文件。 对， 就是这么简单， 通过设定爬取周期，就可以得到很多代理 IP 了。自动投票系统其实这种自动刷票的功能不是很愿意做， 但为了学习还是可以练习一下的。 1、目标网站http://jljapi.manhuadao.cn/Vote/vote 2、编写投票函数(这里 请求比较简单，直接用 CURL) 123456789101112131415function voteByIP ($ip, $port) &#123; $post_data = array ("bookid" =&gt; "102428"); $ch = curl_init("http://jljapi.manhuadao.cn/Vote/vote"); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_PROXY,$ip); curl_setopt($ch,CURLOPT_PROXYPORT,$port); curl_setopt ($ch, CURLOPT_TIMEOUT, 1200); $result = curl_exec($ch); print_r($result.PHP_EOL); curl_close($ch);&#125; 3、使用不同的 IP 发起投票请求 123456789$ipPoolArr = json_decode(file_get_contents('ipPool.json'));foreach ($ipPoolArr as $key=&gt;$proxyStr)&#123; $ip = $proxyArr[0]; $port = $proxyArr[1]; voteByIP($ip, $port)&#125; 4、自动循环投票Shell脚本 12345678#!/bin/bashfor((i=1;i&lt;=99999999999999999999999999999999999999;i++)); do php autoVote.php //还可以执行其他的操作，例如 php getIPPool.php 来更新代理 IP 池done 5、功能扩展 其实这里只是做了简单自动爬虫和投票功能， 从获取代理 IP 到投票， 本地的 IP使用完之后刷新 IP 池。因此，可以扩展的功能有： 1、把代理 IP 池存储到数据；2、不定时发起投票请求， 防止频繁请求被封禁，虽然切换了代理 IP。3、统计代理 IP 的使用情况和对应的投票成功率；4、ETC 总结本文使用 Goutte爬虫框架实现爬取代理 IP 池，然后利用得到的 IP来 自动投票。这里只是 Goutte 的简单用法，更多用法可以查看 Goutte 官方文档。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>Goutte</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins自动部署React前端项目]]></title>
    <url>%2F2017%2F10%2F28%2F%E4%BD%BF%E7%94%A8Jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2React%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[经过一个月的开发，公司的 React 项目基本进入测试阶段，最开始是手动打包并传送到目标服务器，效率十分低下。w闻将介绍如何用 Jenkins 实现 React 项目的自动打包和部署。 安装Java 和 Jenkins1、略过安装 Java2、下载 Jenkins 的 war包3、根据提示安装 Jenkinswar包启动方式：java -jar jenkins.war –httpPort=8080,端口可自定义，然后访问http://ip:8080 4、插件管理点开系统设置的插件管理页面，如果可选插件列表为空，点击高级标签页，替换升级站点的URL为：http://mirror.xmission.com/jenkins/updates/update-center.json并且点击提交和立即获取 5、返回可选插件，选择如下插件安装（如果已安装，请忽略）1).Publish Over SSH2).GitLab Plugin3).Email Extension Plugin 插件配置配置Publish Over SSH在Publish over SSH处点击增加，添加SSH server，并且选择高级设置，勾选使用用户名登录，设置相应的ip,用户名和密码等。（其他选项可忽略） 配置Email Extension Plugin 新建任务1、新建项目点击新建，输入项目名称，选择‘自由风格项目’，OK 2、配置源码选择Git，并填上gitlab项目克隆地址，用户密钥以及分支 3、配置构建触发器勾选Build when a change is pushed to GitLab和Poll SCM即可，其他可忽略，默认提交代码到相应的分支触发该任务。 4、配置构建 5、配置构建后操作增加构建后操作，选择Send build artifacts over SSH。即上述操作全部完成并自动生产了部署文件，该步骤将部署文件上传到之前的SSH服务器（Linux服务器），并执行你想让他执行的命名，部署多个服务器及平台，选择添加server并完成相应的配置 （1）、构建后配置 Email（可选）配置后再增加构建后操作，选择Editable Email Notification。根据提示配置需要通知的邮箱，其他可默认。然后选择高级设置，配置失败和成功邮件通知。 （2）、构建后执行 Shell命令（可选）增加构建后操作 ，选择Post build task。根据 匹配 Log 的文本消息执行不同的 shell 命令，Log 文本的匹配需要根据实际情况修改，可使用简单正则表达式。这里执行的命令可以是一个 shell脚本，把自己需要执行的任务写到脚本中。 绑定 Gitlabs Web hooks添加web hook. http://jenkins-server/gitlab/notify_commit 需要填上的固定格式的URL地址，把jenkins-server替换成对应的Jenkins访问地址，注意：如果是localhost，需要换成ip地址。添加完之后，点击Test Hook。此时Jenkins界面构建队列出现某个任务正在执行，表示配置成功。 提交代码验证 Jenkins 功能。我这里使用的构建后任务是发送公司内部 IM 消息，构建后我收到了这样的消息。 nginx 配置由于构建后的 React 文件都是静态文件，我们需要一个 Web 服务器来托管我们的项目。这里使用 nginx,并配置反向代理。这里略过如何安装 nginx，可参考安装 PHP 开发环境的 nginx 安装部分讲一下 nginx 配置的注意点。1、反向代理:反向代理转发时过滤掉 /api路径。 123456location /api &#123; rewrite /api(.*) $1 break;proxy_pass http://localhost:8080; proxy_redirect off; proxy_set_header Host $host; &#125; 2、react-router 失效。可能会有朋友注意到，当刷新页面时，nginx 会返回404响应。这是因为nginx 查找的路由是浏览器上的地址，但我们的项目不存在这样的路由，所以会出错。我们需要把所有的请求都重定向到 index.html 文件。在 location / {}里增加： 1try_files $uri /index.html; 完毕]]></content>
      <tags>
        <tag>React</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发笔记]]></title>
    <url>%2F2017%2F10%2F21%2FReact%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[由于公司产品需要，最近一个月开始了 web 前端开发，技术栈是 webpack+react+mobx 的 react 全家桶架构。 什么是 react文章的开始还是有必要介绍一下 react 的概念。react.js 是 FaceBook 研发的前端 JS 框架，主要 特色是使用虚拟 DOM，性能卓越。其本质还是使用 javascript 作为开发语言。但需要注意的是现在一般使用 ES6的新特性作为主流开发。这里不详细阐述各个概念了，可以自行查看相关资料。 应用框架结构设计这次的 react 开发应该算是我真正第一次独自负责，距离上一次的 react学习以及过去几个月的时间，当时react的版本 已经到了v15.6(现在 v16已经发布)，每个大版本的特性还是不大一样。尤其是 react-router4和 router3的区别很大，所以重新阅读最新的 react 开发文档是最稳妥的。由于这次的应用是对之前用传统 jquery 开发的系统进行重构，所以在应用目录结构上是未知数。所有东西都是我自己去把握和决定。在开始的时候，使用了 koa2作为开发服务器，当时是基于这样的考虑：上线后可以继续使用 koa 作为 http 服务器，就不用配置 nginx 或者其他服务器，但几天后发现，很多东西还是跟传统的 mvc 框架的开发模式差不多，要定义很多的路由，使得整个开发效率大大降低。这种情况下，我决定推翻现有的架构，从零搭建一个 react 初始化模板。该模板的地址https://github.com/moxun33/react-mobx-antd-boilerplate。该模板使用的技术栈是 webpack+react+mobx+router4,前端 UI 是 ant-design。 组件化开发我们都知道，在之前的jquery 开发的方式中，代码的组织和方式基本按照一个页面进行归类，不管这个页面需要多少的 js 代码都需要写在同一个文件，虽然有人会说我可以拆分一些出来啊，然而最后还是要引入到同个文件，而且文件之间的关系不够清晰，带来的问题就是维护难，代码可读性差。正是基于这个考虑，我们公司才决定使用 react 进行组件化开发。所谓的组件化管理，就是利用 ES6或之后的版本的 js 特性配合 react 的设计思想，对一个页面划分不同的组件，最后把这些组件导入到一个文件中，而且在组件化开发的过程中可以抽取一些比较通用的组件归并到组件的模块中，久而久之，就形成了我们自己系统的组件库了，对于主题定制和网站风格的定义还是比较有用 的。至于划分组件的标准是什么就不好定义了，打到一个页面，小到一个按钮都可以作为一个组件，在开发的过程中，会很自然的看出应该如何划分页面组件，但要记住的一点的，所有组件都是继承与 react 顶级 Component 类中。 高阶组件和 html 模板当使用 react 进行组件化开发时，在不经意中会发现很多代码都是重复的（这里主要讲 react 组件的代码复用，忽略逻辑部分），那应该怎么提高组件代码复用率呢？ 1、高级组件 一个高阶组件只是一个包装了另外一个 React 组件的 React 组件。这种形式通常实现为一个函数，本质上是一个类工厂（class factory），它下方的函数标签伪代码启发自 Haskell 1hocFactory:: W: React.Component =&gt; E: React.Component 这里 W（WrappedComponent） 指被包装的 React.Component，E（Enhanced Component） 指返回的新的高阶 React 组件。 定义中的『包装』一词故意被定义的比较模糊，因为它可以指两件事情： (1) 属性代理（Props Proxy）：高阶组件操控传递给 WrappedComponent 的 props，(2) 反向继承（Inheritance Inversion）：高阶组件继承（extends）WrappedComponent。 高阶组件允许你做： a、代码复用，逻辑抽象，抽离底层准备（bootstrap）代码b、渲染劫持c、State 抽象和更改d、Props 更改 在目前的开发中，我只用了高级组件来包裹网站的权限组件，轻松管理完整元素权限和逻辑权限问题；还有就是解决在不同页面使用相同布局问题的重复工作；至于其他的用途在用到时将继续更新。 2、html 模板在很多时候，我们并不需要一个 react 组件去实现我们的一个视图，比如：自定义的列表，这个列表在所有地方都是一样的数据结构和样式，那么我们只需要把静态的 html 代码抽离到同个地方，抽象成一个工具函数，那么在使用的时候，传入模板数据就可以得到相同的视图效果而且不用重复考虑 css 布局问题。还有一个使用这种方式比较多的地方就是表单了，一个网站中表单有很多，但表单的输入框效果都大同小异，只要把当前的 react的 input 组件获取 ant-desing 的 input 组件等再高度定制成我们自己风格的 input 组件，那么在使用的时候，只需要传入特定的函数参数就可以 render 到一样的效果，而不用重复的使用 row 和 col 的去布局。而且这样做可以更好的管理css 样式和公用规则选项。这种方式，还是类似于我们以前的做法，但以前的 js 操作的 dom 是真实的 dom，性能很低，现在只是操作虚拟 dom，保证了网站的西能和开发效率。 遇到的坑1、使用 HOC 时，传入的 wrappedComponent 必须的 React type 例如： 12const addBtn = (&lt;p&gt;hi!!!&lt;/p&gt;) const AddProjectAuthBtn = wrapAuth(()=&gt;addBtn) 常见错误是写成： 12const addBtn = (&lt;p&gt;hi!!!&lt;/p&gt;) const AddProjectAuthBtn = wrapAuth(addBtn) 2、Javascript 中 formData 会把 null 对象转化成”null” 字符串;判断空对象{}的方法是 12const mobject = &#123;&#125;JSON.stringify(mobject) === "&#123;&#125;" 不能直接使用 mobject !== {}或 null 这种方式。 3、ant-design 中 Select 组件同时设置了initialValue 和 placeholder,initialValue 为空的情况下 placeholder不生效,initialValue 不设置或设为 undefined，应该能解决。 4、mobx 中@inject(‘modalStore’) @observer 需要放在其他注解的后面，否则无法更改状态 5、从 http 的 response 中读取图片并显示到 dom 上, 请求的时候 responseType=”arrayBuffer” 12345678getSupplierImageBuffer(&#123;id: attachId&#125;).then((res) =&gt; &#123; const arrayBufferView = new Uint8Array(res); return new Blob([arrayBufferView], &#123;type: "image/jpeg"&#125;) &#125;).then((myBlob) =&gt; &#123; const urlCreator = window.URL || window.webkitURL; const objectUrl = urlCreator.createObjectURL(myBlob); screenshot.src = objectUrl; &#125;) 6、js 获取文件并处罚浏览器的下载功能, http 中 responseType=”blob” 可以使用 download.js 或者其他的 js 文件下载库 当然 可以自定义工具 123456789fetch('http://somehost/somefile.zip').then(res =&gt; res.blob().then(blob =&gt; &#123; var a = document.createElement('a'); var url = window.URL.createObjectURL(blob); var filename = 'myfile.zip'; a.href = url; a.download = filename; a.click(); window.URL.revokeObjectURL(url);&#125;)) 7、FormData 的 append 函数中,如果如果当前 key 对应的值是 null 或者 undefined，那么填入 FormData 中 的数据会变成 “null”或”undefined” 字符串。目前的解决办法时，只 append 飞非 null 的值。 8、react 中每次调用 setState 方法设置新状态都会出发 render 事件， 但并不一定刷新页面，当DOM 树发生变化才会刷新 UI. 9、样式的书写最好用 LESS,这样既可以定义主题也可以提高代码复用率。 10、在编码的过程中需要不断的抽取共同代码， 封装成通用组件，这样才能提高代码质量， 还可以武装专有的‘武器库’。11、前端的 pdf 预览最好使用浏览器自带的预览功能， 使用 iframe 加载 PDF 文件流: 请求 responseType = ‘arraybuffer’ 响应处理 const data = window.URL.createObjectURL(new Blob([res], {type: “application/pdf”})) 预览组件 123&lt;object data=&#123;this.state.contractPDFUrl&#125; width=&#123;&apos;200px&apos;&#125; height=&#123;&apos;100px&apos;&#125; &gt; &lt;embed src=&#123;this.state.contractPDFUrl&#125; width=&#123;&apos;200px&apos;&#125; height=&#123;&apos;100px&apos;&#125; /&gt; &lt;/object&gt; 或者 &lt;iframe src={this.state.contractPDFUrl} width={&#39;400px&#39;} height={&#39;500px&#39;} /&gt; embed 在 windows 下兼容性价差: 在firefox上 无法渲染；iframe 兼容性较好，推荐。 12、避免使用 window.history 或者 window.location; 推荐使用 react-router 。 因为当加入了 mobx 状态管理器后， 使用 window.location刷新页面, 体验较差。 13、 在 使用 mobx 下，当根据mobx 中的@observable isLogined 来判定授权与否， 当登录请求成功后，设置isLoginde d 后，立刻跳转的话， 会出现404的情况， 因为未登录下， 没有设置 router， 解决方法：延时300ms 左右再跳转，可临时解决该问题。推荐解决方法是：把登录页写入相同的路由配置中。 代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/*、*** 验证手机号码* */export const isMobilePoneValid = (str) =&gt; &#123; const myreg = /^1[0-9]&#123;10&#125;$/; return myreg.test(str)&#125;/** * 验证身份证号码 * * */export const isIDNumberValid = (str) =&gt; &#123; const myreg = /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/; return myreg.test(str)&#125;/** * 函数去抖,针对winodw.onresize等事件 * @param &#123;Function&#125; method 需要去抖的方法 */export const debounce = method =&gt; &#123; if (method.timeout) &#123; clearTimeout(method.timeout); &#125; method.timeout = setTimeout(() =&gt; &#123; method(); &#125;, 500);&#125;;/** * 求两个数组的交集,非对象数组 * ES7 let intersection = allData.filter(v =&gt; editData.includes(v)); * */export const findArrayIntersection = (arr1, arr2) =&gt; &#123; if ( Object.prototype.toString.call(arr1) === &apos;[object Array]&apos; &amp;&amp; Object.prototype.toString.call(arr2) === &apos;[object Array]&apos; ) &#123; return arr1.filter(function (v) &#123; return arr2.indexOf(v) !== -1; &#125;); &#125;&#125;;/** * 对象数组的交集, 数据结构必须相同 * */export const findArrayIntersectionOfObject = (list1, list2, key,isUnion = true) =&gt; &#123; if (list2 !== undefined &amp;&amp; list2 !== undefined) &#123; return list1.filter(a =&gt; isUnion === list2.some(b =&gt; a[key] === b[key])); &#125; else &#123; return []; &#125;&#125;;/** * 识别是否为微信浏览器 */export const isWeixinBrowser = () =&gt; /micromessenger/.test(navigator.userAgent.toLowerCase()); /** 根据 key在 object中 获取指定子 object* * key：所查询的 key* value：查询 key 对应的 value* */export const findSubObjectInObject = (data, key, value) =&gt; &#123; let target = &#123;&#125;; for (let item in data) &#123; const object = data[item]; if ( String(object[key]).includes(value) || String(value).includes(object[key]) ) &#123; target = object; &#125; &#125; if (!isObjectValid(target)) &#123; openNotification(&apos;error&apos;, `无法获取$&#123;key&#125;与$&#123;value&#125;的映射`); &#125; return target;&#125;;/** * 在新窗口打开给定的 html 元素（string） * */export const openWinWithHtml = (myHtmlStr,spec = &apos;width=940,resizable=no,height=1200,location=no&apos;) =&gt; &#123; const wnd = window.open(&apos;about:blank&apos;, &apos;_blank&apos;, spec); wnd.document.write(convertStringToHtml(myHtmlStr));&#125;;/** * 自动调整图片宽高 * */export const autoSizeImg = (Img, maxWidth, maxHeight) =&gt; &#123; const image = new Image(); //原图片原始地址（用于获取原图片的真实宽高，当&lt;img&gt;标签指定了宽、高时不受影响） image.src = Img.src; // 当图片比图片框小时不做任何改变 if (image.width &lt; maxWidth &amp;&amp; image.height &lt; maxHeight) &#123; Img.width = image.width; Img.height = image.height; &#125; else &#123; //原图片宽高比例 大于 图片框宽高比例,则以框的宽为标准缩放，反之以框的高为标准缩放 if (maxWidth / maxHeight &lt;= image.width / image.height) &#123; //原图片宽高比例 大于 图片框宽高比例 Img.width = maxWidth; //以框的宽度为标准 Img.height = maxWidth * (image.height / image.width); &#125; else &#123; //原图片宽高比例 小于 图片框宽高比例 Img.width = maxHeight * (image.width / image.height); Img.height = maxHeight; //以框的高度为标准 &#125; &#125; return Img;&#125;; 后续会继续更新]]></content>
      <tags>
        <tag>React</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 下使用Vagrant 构建跨平台开发环境]]></title>
    <url>%2F2017%2F09%2F03%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8Vagrant-%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Vagrant 是一款用来构建虚拟开发环境的工具，非常适合 php/python/ruby/java 这类语言开发 web 应用，“代码在我机子上运行没有问题”这种说辞将成为历史。本文通过安装php开发环境homestead来说明 Vagrant 的安装使用与优点。 我们可以通过 Vagrant 封装一个 Linux 的开发环境，分发给团队成员。成员可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发,这样不仅保证代码运行环境一致，还可以节省部署开发环境带来的不必要时间开销，让团队新成员快速投入开发工作中。 安装步骤1、安装VirtualBox下载地址：https://www.virtualbox.org/wiki/Downloads;虽然 Vagrant 也支持 VMware，但是VMware 对应的 Vagrant 版本也是收费的。 2、安装 VagrantVagrant 的下载地址https://www.vagrantup.com/downloads.html;下载好后，打开 Vagrant镜像一步一步的安装。使用 $ vagrant -v 查看是否安装成功。 3、添加box镜像Vagrant 安装成功后，运行 vagrant box add laravel/homestead 命令将 laravel/homestead 盒子添加到 Vagrant 中安装。下载盒子需要几分钟的时间，具体取决于你的互联网连接速度。 但一般国内网络环境下都会失败。那么我们需要离线安装 box 。下载homestead 离线安装包;下载完成后，运行 vagrant box add laravel/homestead ~/Download/virtualbox.box 此处路径只是为了演示。 因为是手动导入包，还需要多更改几个步骤。 编辑Homestead/scripts/homestead.rb文件 修改 config.vm.box_version = settings["version"] ||= ">= 1.0.0" 改成 config.vm.box_version = settings["version"] ||= ">= 0 这样就安装离线安装好 homestead box 了。可以使用 vagrant up 来启动 box 了。 4、克隆和配置homestead文件在目标目录，运行 git clone https://github.com/laravel/homestead.git Homestead 由于 Homestead 的 master 分支并不是稳定分支，你应该用打过标签的稳定版本。你可以在 Github 发行页面 上找到最新的稳定版本。 cd Homestead // Clone the desired release... git checkout v6.1.0 克隆 Homestead 代码库后，从 Homestead 目录中运行bash init.sh 命令来创建 Homesstead.yaml 配置文件。 Homesstead.yaml 文件会被放置在你的 Homestead 目录中：运行命令来初始化配置 bash init.sh 其他详细的配置参考官方文档，这里不再赘述。 5、初始化开发环境切换到目标目录，使用 vagrant init laravel/homestead初始化该目录的环境。然后启动环境vagrant up。 看到终端显示了启动过程，启动完成后，我们就可以用 SSH 登录虚拟机了，剩下的步骤就是在虚拟机里配置你要运行的各种环境和参数了。 $ vagrant ssh # SSH 登录 $ cd /vagrant # 切换到开发目录，也就是宿主机上的 工作目录 6、其他设置Vagrant 初始化成功后，会在初始化的目录里生成一个 Vagrantfile 的配置文件，可以修改配置文件进行个性化的定制。 Vagrant 默认是使用端口映射方式将虚拟机的端口映射本地从而实现类似 http://localhost:80 这种访问方式，这种方式比较麻烦，新开和修改端口的时候都得编辑。相比较而言，host-only 模式显得方便多了。打开 Vagrantfile，将下面这行的注释去掉（移除 #）并保存： config.vm.network :private_network, ip: "192.168.33.10" 重启虚拟机，这样我们就能用 192.168.33.10 访问这台机器了，你可以把 IP 改成其他地址，只要不产生冲突就行。 7、设置共享文件夹打开 Vagrantfile,输入以下代码或者去掉注释config.vm.synced_folder “/Users/name/nginxWeb”, “/wwwroot”第一个是你本地的文件夹 第二个是挂在到虚拟机上的文件夹 给共享文件夹设置权限 默认共享文件夹属主 和属组都是 vagrant 我们如果php操作文件夹 是没权限的 要把该文件夹设置成 www用户 config.vm.synced_folder "/Users/gwyy/wwwroot","/wwwroot", create:true, :owner => "www", :group => "www", :mount_options => ["dmode=775","fmode=664"] 打包分发虽然我们这里的用 laravel 官方的开发环境， 其他成员可以使用同样方法搭建好一致的开发环境。那么，如果我们需要根据自己的开发需求来定制 box 后该如何打包分发给其他成员呢。当你配置好开发环境后，退出并关闭虚拟机。在终端里对开发环境进行打包： vagrant package 打包完成后会在当前目录生成一个 package.box 的文件，将这个文件传给其他用户，其他用户只要添加这个 box 并用其初始化自己的开发目录就能得到一个一模一样的开发环境了。 常用命令 $ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 注意事项1、使用 Apache/Nginx 时会出现诸如图片修改后但页面刷新仍然是旧文件的情况，是由于静态文件缓存造成的。需要对虚拟机里的 Apache/Nginx 配置文件进行修改： # Apache 配置添加: EnableSendfile off # Nginx 配置添加: sendfile off; 2、如果访问出现 no input file specified 输入 vagrantprovision]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>Vagrant</tag>
        <tag>Homestead</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 的几种通信方式]]></title>
    <url>%2F2017%2F08%2F18%2Fweb%20%E7%9A%84%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上一篇文章中主要讲述一个完整的HTTP请求过程，了解一个连接是如何建立的。那么，这里再来聊聊web 中常用的几种通信方式，主要讲述其概念和应用场景或实现方式。概况一下，主要有四种方式，它们分别是短轮询、长轮询(comet)、长连接(SSE)、WebSocket。它们大体可以分为两类，一种是在HTTP基础上实现的，包括短轮询、comet和SSE；另一种不是在HTTP基础上实现是，即WebSocket。 Ajax 轮询1、原理（1）、客户端向服务器端发起请求，和上面最基本的请求原理是一样(2)、不同的是该请求方式是通过Ajax实现，设定一定的间隔时间对服务器发送请求(比如1 秒)，通过setInterval()方法，实现每隔一段时间向服务器发送请求的功能。(3)、服务器端返回结果到客户端 2、实现（1）、前端实现 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;短轮询ajax实现&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;msgs&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function showUnreadNews()&#123; $(document).ready(function() &#123;//使用jquery的ajax方法 $.ajax(&#123; type: &quot;GET&quot;, url: “shortAjax.php&quot;, dataType: &quot;json&quot;, success: function(msg) &#123; $.each(msg, function(id, title) &#123; $(&quot;#msgs&quot;).append(&quot;&lt;a&gt;&quot; + title + &quot;&lt;/a&gt;&lt;br&gt;&quot;); &#125;); &#125; &#125;); &#125;); &#125; setInterval(&apos;showUnreadNews()&apos;,2000);//2秒请求一次&lt;/script&gt;&lt;/html&gt; （2）后端实现 1234&lt;?php$arr = array(&apos;title&apos;=&gt;&apos;标题&apos;,&apos;text&apos;=&gt;&apos;内容&apos;); //服务器端更新的数据echo json_encode($arr); //返回数据?&gt; 3、应用这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。最初是用来实现实时更新数据的， 但服务器的压力和用户数成正比，最终会超过服务器的承受范围，造成严重后果。因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。 comet1、原理comet与传统的ajax区别在于，客户端会与服务器端保持一个长连接，此时该连接先挂起，不做响应。只有当客户端需要的数据更新时，服务器才会主动将数据推送给客户端。comet的实现有两种方式，一种方式是使用基于ajax的长轮询，另一种方式是基于Iframe及htmlfile的流方式。基于ajax的长轮询方式中，服务器端在接受到客户端ajax发送的请求后，不立即返回响应，而是阻塞请求直到超时或有数据更新。当服务器端在上述情况下返回响应后，客户端通过js再次发送请求建立连接，重复上述步骤。 2、实现前端实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;长轮询ajax实现&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;click&quot;&gt;&lt;div id=&quot;msg&quot;&gt;数据情况&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; $(&quot;#btn&quot;).bind(&apos;click&apos;,&#123;btn:$(&apos;#btn&apos;)&#125;,function(e)&#123; $.ajax(&#123; type: &apos;POST&apos;, dataType: &apos;json&apos;, url: &apos;ajax.php&apos;, timeout: &apos;20000&apos;,//设置请求超时时间 data: &#123;time: &apos;2000000&apos;&#125;,// 每次请求等待时间，将其传到后台用来挂起请求 success: function(data,status)&#123;//对返回的数据进行判断和读取 if(data.success == &apos;1&apos;)&#123; $(&quot;#msg&quot;).append(&apos;&lt;br&gt;[有数据]&apos;+data.text); e.data.btn.click(); //再此发送请求 &#125; // 未从服务器中获的数据 if(data.success == &apos;0&apos;)&#123; $(&quot;#msg&quot;).append(&apos;&lt;br&gt;[无数据]&apos;); e.data.btn.click(); &#125; &#125;, // ajax超时,继续查询 error:function(XMLHttpRequest,textStatus,errorThrown)&#123; if(textStatus == &quot;timeout&quot;)&#123; $(&quot;#msg&quot;).append(&apos;超时&apos;); e.data.btn.click(); &#125; &#125; &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 后端 PHP 实现 12345678910111213141516&lt;?php set_time_limit(0);// 无限请求超时时间 usleep($_POST[&apos;time’]);//通过前台传过来的数据设置挂起时间 while(true)&#123; //无限循环 $rand = rand(1,999); if($rand &lt; 500)&#123; $arr = array(&apos;success&apos;=&gt;&apos;1&apos;,&apos;name&apos;=&gt;&apos;有值&apos;,&apos;text&apos;=&gt;$rand); echo json_encode($arr); exit(); &#125;else&#123; $arr = array(&apos;success&apos;=&gt;&apos;0&apos;,&apos;name&apos;=&gt;&apos;无值&apos;,&apos;text&apos;=&gt;$rand); echo json_encode($arr); exit(); &#125; &#125;?&gt; 3、应用长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。应用场景跟短轮询相差无几。 SSE1、概述SSE是HTML5新增的功能，全称为Server-SentEvents。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。 2、原理SSE不需要依赖客户端向服务器发送请求，而是可以直接在服务器端有数据更新时进行发送到客户端，相比于轮询的“拉数据”，这种“推数据” 有着低延迟、高性能的优势。 这种方法的服务器端非常简介，只要维护一个服务器和客户端之间的协议即可。前端使用EventSource对象。 服务器端需要提供的协议基本代码如下： data:firstevent data:secondevent id:100 event:myevent data:thirdevent id:101 :thisisacomment data:fourthevent data:fourtheventcontinue 下面解释一下基本用法。要定义各个事件，每一个事件之间使用一个换行符隔开。每个事件内部可以有多行，每一行都是type:value的形式。type有以下集中选择： (1)类型为空白，表示该行是注释，会在处理时被忽略。 (2)类型为data，表示该行包含的是数据。以data开头的行可以出现多次。所有这些行都是该事件的数据。 (3)类型为event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。 (4)类型为id，表示该行用来声明事件的标识符。 (5)类型为retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。 比如上面的第一个事件，只传输了一个数据，数据内容为firstevent。服务器端通过这个清单发送到客户端，就可以通过前端进行响应的处理，诸如读取新数据、更新界面等。 客户端需要在JavaScript中使用EventSource对象。 首先需要初始化一个EventSource对象，实例化的时候需要传入与其交互的服务器端的文件地址，如： vares=newEventSource(“sse.php”); 接下来，可以对进行事件的监听。EventSource给出了三种标准事件，它们的名称和触发时机如下表： open 当成功与服务器建立连接时执行 message 当收到服务器发送的事件时执行 error 当出现错误时执行 和普通的事件一样，可以通过以下两种方法使用这些事件： es.onmessage=function(e){}; es.addEventListener(“message”,function(e){}); 3、实现前端实现 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;basic SSE test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=”content”&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var es = new EventSource(&quot;sse.php&quot;); es.addEventListener(&quot;message&quot;,function(e)&#123; document.getElementById(&quot;content&quot;).innerHTML += &quot;\n&quot;+e.data; &#125;); &lt;/script&gt;&lt;/html&gt; 后端 PHP 实现 1234567&lt;?phpheader(&apos;Content-Type: text/event-stream&apos;); //这是专门为sse设置的数据格式$time = date(&apos;Y-m-d H:i:s&apos;);//下面这些echo出来的东西就是上面说的服务器端和客户端之间的协议echo &apos;retry: 3000&apos;.PHP_EOL; //retry类型的数据，规定了浏览器在连接断开之后进行再次连接之前的等待时间echo &apos;data: The server time is: &apos;.$time.PHP_EOL.PHP_EOL;?&gt; #### 4、应用SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且SSE的实现非常简单，并且不需要依赖其他插件。 WEBSOCKET1、原理WebSocket一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。WebSocket API也被W3C定为标准。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 Websocket是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。 Websocket的数据传输是frame形式传输的，比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处： 1 大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。 2 和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。 2、实现客户端实现 12345678910111213141516var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) &#123; console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);&#125;;ws.onmessage = function(evt) &#123; console.log( &quot;Received Message: &quot; + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log(&quot;Connection closed.&quot;);&#125;; 说明：WebSocket提供了四个事件操作，如下： onmessage 收到服务器响应时执行 onerroe 出现异常时执行 onopen 建立起连接时执行 onclose 断开连接时执行 服务端实现WebSocket 服务器的实现，可以查看维基百科的列表。具体的用法也不一一列举。 3、应用 社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。大家感受最深刻的就是微信聊天和 QQ 聊天了。 最后：WebSocket和Socket的区别与联系首先，Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。 Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 Socket在通讯过程中，服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端也都可以相互发送消息与对方进行通讯，直到双方连接断开]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊 web 中的网络请求]]></title>
    <url>%2F2017%2F07%2F08%2F%E8%81%8A%E8%81%8A-web-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[现在大多数情况都需要使用计算机，而大部分计算机都会联网。那么在联网的过程中计算机和其他网络设备需要做哪些操作才开确保网络请求成功并返回需要的数据呢？ 本文着重阐述 http请求过程中，即从浏览器请求开始到成功显示返回数据的过程， 会有哪些操作呢？ 完整的http 请求过程概括为 0、浏览器本地缓存匹配； 1、本地hosts映射对比; 2、本地dns缓存解析； 3、远程(运营商）dns解析获得服务器ip地址； 4、浏览器发送tcp连接请求包(syn)； 5、TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了； 6、服务器端接收到请求，根据路径参数，经过处理（包括数据库操作， 计算操作等等），把处理后的一个结果的数据返回给浏览器； 7、浏览器收到结果后， 进行 html 解析， 渲染页面， 把页面呈现给用户； 关键概念HTTP连接 HTTP协议即超文本传送协议(Hypertext Transfer Protocol)，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常 的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 三次握手 简单解释ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。 1、第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；2、第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；3、第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。 当然图片不是我画的， 知识用来引导解释。而且图中还有四次挥手的过程， 这个就不阐述了， 是指数据传输后断开 TCP连接的过程。 为什么要三次握手对于初学者可能不理解为何要三次握手， 那如果只有两次握手会是什么样子的呢？ 举个两次握手的反面例子， 两个人面对面站着， 其中一人 A想给对方 B 传送口信，A 问对方 B 我要开始传送了， B听到后说可以， 传过来吧？B 说完这句话后被其他事情打扰了， 若此时 A把口信传给 B,那 B 肯定听不到了。就造成传信失败了。但三次握手的存在是为了保证传输能成功进行，并且在可控的范围内完成传输。 扩展阅读本人也只是半桶水， 只根据自己的理解写了本文。 若想了解更多， 推荐一些文章，加深理解。 TCP三次握手详解及释放连接过程首先简单介绍一下TCP三次握手TCP 为什么是三次握手，为什么不是两次或四次？面试时，你被问到过 TCP/IP 协议吗?HTTP 权威指南]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用 PHP 拼接微信好友头像]]></title>
    <url>%2F2017%2F06%2F13%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-PHP-%E6%8B%BC%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[最近做个人微信机器人挺热门的， 同时很多人也用来对自己的微信好友做分析和统计， 比如：简单的就是利用微信好友的头像做成一张大图， 让朋友圈的好友都看到彼此， 觉得蛮有意思的! 网上已经有 Python 或 Nodejs 的实现了， 我就想用 PHP 来实现一下。 1、如何选一个微信爬虫。所谓的微信爬虫就是利用微信的 web api 做一些自动化的事情，这里强烈推荐由 PHP7实现的vbot, 所有的东西都可以在 vbot 的文档里找到， 在微信 web api 的范围内你都可以为所欲为了。注意： 本文所有的微信数据都基于 vbot 获取的。2、如何爬取微信好友的头像。首先要获取的是你的微信好友列表， 在 vbot 的基础上我们可以这样做：1File::saveTo(__DIR__.'/contacts.json', $contacts['friends']); 把微信好友列表写入到一个文件中。然后对这个文件进行处理， 提取微信好友的头像链接和下载。123456$contactAmount = $friends-&gt;count(); for($i=0; $i&lt; $contactAmount; $i++)&#123; $data = $friends-&gt;getAvatar(self::$usernameArr[$i]); file_put_contents(__DIR__.'/avatars/'.$i.'.jpeg',$data); &#125; 就这样， 我们就已经能把所有的微信好友头像下载到指定的地方了。注意：建议图片的命名规则用数字递增的方式， 方便后面的图片拼接循环。3、图片拼接本文的重点来了， 现在网上有很多图片拼接小工具， 但 PHP 实现的寥寥无几， 找了一轮后， 决定还是自己写。（1）首先，要确定画布的长度和宽度。那怎么根据图片数量确定画布大小呢。我们门这样分析：由于微信头像的宽高相等， 那我们拼接到画布的托也是宽高相等，这里全部设置为200px， 那么， 只要确定行数和列数， 就知道画布的大小了。还有一点注意：当图片数量小于4张时， 我们只需要一行（或者一列）即可。 当图片数大于3时： a、确定列数（每行多少张）：列数 = 总数（大于3）的平方根， 向上取整b、确定行数（每列多少张）：总数（大于3）除以列数， 向上取整 这里的行数和行数的计算方式是为了尽可能使画布的宽度和高度差值减小。你也可以根据自己的好修改计算方法， 但一定要跟后面的图片排列的行数和列数一致， 否则会出现图片越界的问题。 知道了行数和列数， 那很容易得出画布的宽高 c、画布宽度 = 图片宽度（200px）乘以 列数d、画布高度 = 图片高度（200px）乘以 行数 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 根据图片数据计算画布的大小 * 默认每张图宽度高度 = 200 * 画布大小计算方法： * 列数 = 总数（大于3）的平方根， 向上取整 * 行数 = 总数（大于3）除以列数， 向上取整 * @param $imageCount */ private function prepareForCanvas($imageCount)&#123; $canvasWidth = 0; $canvasHeight = 0; if ($imageCount &gt; 0) &#123; //宽度 = 列数*200 if ($imageCount &lt; 4) &#123; $canvasWidth = $this-&gt;width*$imageCount; $this-&gt;eachLineCount = $imageCount; $canvasHeight = $this-&gt;height; &#125;else&#123; $this-&gt;eachLineCount = ceil(sqrt($imageCount)); //列数 $this-&gt;eachColumCount = ceil($imageCount/$this-&gt;eachLineCount); $canvasWidth = $this-&gt;width * $this-&gt;eachLineCount; $canvasHeight = $this-&gt;height * $this-&gt;eachColumCount; &#125; &#125; echo '图片总数：'.$imageCount.PHP_EOL; //创建画布 $this-&gt;createCanvas($canvasWidth, $canvasHeight); &#125; /**创建画布 * @param $width * @param $height */ private function createCanvas($cwidth, $cheight) &#123; $totalImage = count($this-&gt;srcImages); $this-&gt;canvas = imagecreatetruecolor($cwidth, $cheight); // 使画布透明 $white = imagecolorallocate($this-&gt;canvas, 255, 255, 255); imagefill($this-&gt;canvas, 0, 0, $white); imagecolortransparent($this-&gt;canvas, $white); echo '画布大小:长度：'.$cwidth.'，高度：'. $cheight.PHP_EOL. '每行数量（列数）：'.$this-&gt;eachLineCount.',每列数量（行数）：'.$this-&gt;eachColumCount.PHP_EOL; &#125; 4、画布建好了， 接下来就是拼接图片了。这里的难点在于确定图片在哪个位置。a、图片数小于4时， 只有一行， 每张图片的 y 值都是0， x 值随图片数每次递增200px。b、图片数大于3时， 循环复制图片到画布上， 当图片的序号等于列数的倍数时， 就要换行， 那么 x 值从0开始， y 值递增200px； 以此类推，直到所有图片复制到画布上。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 合并图片 */public function combine() &#123; if (empty($this-&gt;srcImages) || $this-&gt;width==0 || $this-&gt;height==0) &#123; return; &#125; $imageCount = count($this-&gt;srcImages); $this-&gt;prepareForCanvas($imageCount); for($i=0; $i&lt; $imageCount; $i++) &#123; $srcImage = $this-&gt;srcImages[$i]; $srcImageInfo = getimagesize($srcImage); // 如果能够正确的获取原图的基本信息 if ($srcImageInfo) &#123; $srcWidth = $srcImageInfo[0]; $srcHeight = $srcImageInfo[1]; $fileType = $srcImageInfo[2]; if ($fileType == 2) &#123; // 原图是 jpg 类型 $srcImage = imagecreatefromjpeg($srcImage); &#125; else if ($fileType == 3) &#123; // 原图是 png 类型 $srcImage = imagecreatefrompng($srcImage); &#125; else &#123; // 无法识别的类型 continue; &#125; //只支持横向 // 计算当前原图片应该位于画布的哪个位置 if ($i &lt; $this-&gt;eachLineCount)&#123; $destX = $i * $this-&gt;width; $desyY = 0; $currentRowIndex = 0; &#125;else&#123; //计算该图片应该在第几行， 第几列 $tmp = ($i+1)/$this-&gt;eachLineCount; if (($i+1)%$this-&gt;eachLineCount == 0)&#123; $currentRowIndex = $tmp -1; &#125;else&#123; $currentRowIndex = floor($tmp); &#125; $destX = ($i - $currentRowIndex*$this-&gt;eachLineCount)*$this-&gt;width; $desyY = $currentRowIndex*$this-&gt;height; &#125; echo '当前索引:'.$i.',当前行的索引: '.$currentRowIndex.',图片位置 X: '.$destX.',图片位置 Y: '.$desyY.PHP_EOL; imagecopyresampled($this-&gt;canvas, $srcImage, $destX, $desyY, 0, 0, $this-&gt;width, $this-&gt;height, $srcWidth, $srcHeight); &#125; &#125; // 如果有指定目标地址，则输出到文件 if ( ! empty($this-&gt;destImage)) &#123; $this-&gt;output(); &#125;&#125; 5、效果预览 6、完整的代码https://github.com/moxun33/imageMergerUtil]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲谈 PHP7新特性]]></title>
    <url>%2F2017%2F05%2F27%2F%E9%97%B2%E8%B0%88-PHP7%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[PHP7已经发布有段时间了，其最大的特点是快。其性能高于 HHVM， 是 PHP5.6的两倍。本人就整理一些PHP7.0.x的新特性，也当做自己学习和复习PHP7。 0、可变参数PHP7允许传入可变个数的同类型参数12345678&lt;?php function sum(int ...$ints)&#123; return array_sum($ints);&#125;var_dump(sum(4, 5, 6, 7)); 输出1int(22) 1、标量类型声明标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。它们扩充了PHP5中引入的其他类型：类名，接口，数组和 回调类型。12345678&lt;?php// 强制模式function sum(int ...$ints)&#123; return array_sum($ints);&#125;var_dump(sum(4, '5', 6.1)); 输出1int(15) 要使用严格模式需要在文件顶部添加 declare(strict_types=1);在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个TypeError。 严格类型仅用于标量类型声明，也正是因为如此，这需要PHP 7.0.0 或更新版本，因为标量类型声明也是在那个版本中添加的。例子 12345678910&lt;?phpdeclare(strict_types=1);function sum(int $m, int $n) &#123; return $m + $n;&#125;var_dump(sum(0, 1));var_dump(sum(0.5, 1.5));?&gt; 输出12345int(2)Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, Stack trace:#0 -(9): sum(0.5, 1.5) 3、函数返回类型声明PHP 7 增加了对返回类型声明的支持。函数返回值的类型必须与声明的类型一致， 否则会抛出错误。12345678910&lt;?phpfunction arraysSum(array ...$arrays): array&#123; return array_map(function(array $array): int &#123; return array_sum($array); &#125;, $arrays);&#125;print_r(arraysSum([1,2,3], [4,5,6], [7,8,9])); 输出1234567891011121314Array( [0] =&gt; 6 [1] =&gt; 15 [2] =&gt; 24)#### 由于近期有学习 Swift，这种写法和 Swift 类似：在 Swift 中```phpfunc test(a: String) -&gt; String &#123; let b = a + "b" return b&#125; 3、null合并运算符PHP7中添加了null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。123456789101112&lt;?php// Fetches the value of $_GET['user'] and returns 'nobody'// if it does not exist.$username = $_GET['user'] ?? 'nobody';// This is equivalent to:$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';// Coalesces can be chained: this will return the first// defined value out of $_GET['user'], $_POST['user'], and// 'nobody'.$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';?&gt; 4、太空船操作符（组合比较符）太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。12345678910111213141516&lt;?php// 整数echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1// 浮点数echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串echo "a" &lt;=&gt; "a"; // 0echo "a" &lt;=&gt; "b"; // -1echo "b" &lt;=&gt; "a"; // 1?&gt; 5、通过 define() 定义常量数组PHP7中Array 类型的常量现在可以通过 define() 来定义。在 PHP5.6 中仅能通过 const 定义。123456789&lt;?phpdefine('ANIMALS', [ 'dog', 'cat', 'bird']);echo ANIMALS[1]; // 输出 "cat"?&gt; 5、匿名类PHP7支持通过new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义。1234567891011121314151617181920212223242526&lt;?phpinterface Logger &#123; public function log(string $msg);&#125;class Application &#123; private $logger; public function getLogger(): Logger &#123; return $this-&gt;logger; &#125; public function setLogger(Logger $logger) &#123; $this-&gt;logger = $logger; &#125;&#125;$app = new Application;$app-&gt;setLogger(new class implements Logger &#123; public function log(string $msg) &#123; echo $msg; &#125;&#125;);var_dump($app-&gt;getLogger());?&gt; 6、use 批量声明PHP 7 中 use 可以在一句话中声明多个类或函数或 const 了：1234&lt;php use some/namespace/&#123;ClassA, ClassB, ClassC as C&#125;; use function some/namespace/&#123;fn_a, fn_b, fn_c&#125;; use const some/namespace/&#123;ConstA, ConstB, ConstC&#125;; 但还是要写出每个类或函数或 const 的名称（并没有像 python 一样的 from some import * 的方法）。需要留意的问题是：如果你使用的是基于 composer 和 PSR-4 的框架，这种写法是否能成功的加载类文件？其实是可以的，composer 注册的自动加载方法是在类被调用的时候根据类的命名空间去查找位置，这种写法对其没有影响。7、其他特性其他的特性包括但不限于1、Int64支持，统一不同平台下的整型长度，字符串和文件上传都支持大于2GB。2、统一变量语法（Uniform variable syntax）。3、Unicode字符格式支持（\u{xxxxx}）4、移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展 有兴趣直接访问官网 http://php.net/manual/zh/migration70.new-features.php]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>PHP7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 ngrok 实现内网穿透]]></title>
    <url>%2F2017%2F04%2F04%2F%E4%BD%BF%E7%94%A8-ngrok-%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[由于平时需要进行微信接口开发，最让人头疼的是微信的接口配置一定要是公网 IP；我在本地编码了，每次都要传到服务器进行调试，不仅开发效率低，而且无法定位 BUG 。本文将介绍如何从这种困扰中走出，让我们在本地轻松的进行微信调试。 网上有很多 ngrok 公共端，用户可以直接使用。如果还不知道什么的 ngrok；请参考ngrok 本文使用的 ngrok 服务方是http://ittun.com/1、前往http://ittun.com/下载对应操作系统的客户端。2、下载完成后，解压得到可执行文件。Windows 系统比较简单，直接双击startup.bat运行即可;命令启动： 123linux: ./ngrok [port] (tcp: ./ngrok -proto=tcp 22) windows: ngrok [port] (tcp: ngrok -proto=tcp 22) 更多:ngrok –help 3、使用二级域名。经过我的测试，其他很多的 ngrok 公共端都需要注册登录而且限制使用自定义二级域名， 这是我找到最好的提供商了。直接运行下面代码： 1./ngrok --subdomain [demo] 80 4、当然也可以指定配置文件1./ngrok -config ittun.yml start [proname] 5、如果嫌以上不走麻烦，不妨写一个简单的 SHELL 脚本。每次启动只要运行该脚本即可。（1）创建 startup.sh 文件。在里面写入 123#! /bin/bash ./ngrok -subdomain mywechat 80 ./ngrok -config config.yml start (2) 每次需要启动 ngrok 服务的时候，直接运行 1sh startup.sh （3）、运行效果 6、测试微信接口配置配置成功。然后就专注编码吧！]]></content>
      <tags>
        <tag>ngrok</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql 数据库笔记]]></title>
    <url>%2F2017%2F03%2F18%2Fpostgresql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近学习 PostgreSQL 的笔记。（不定时更新） 学习环境是 Mac 系统 安装最后自动初始化了一个数据库路径为 /usr/local/val/postgres 启动Postgresql 1pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start 停止Postgresql 1pg_ctl -D /usr/local/var/postgres stop -s -m fast 新建一个数据库用户 1createuser weixinadmin -P 为这个用户新建一个数据库 1createdb database -O weixinadmin -E UTF8 -e 用这个用户访问数据库 1psql -U weixinadmin -d weixindb -h 127.0.0.1 PostgreSQL 数据库操作显示已创建的数据库： 1\l 在不连接进 PostgreSQL 数据库的情况下，也可以在终端上查看显示已创建的列表： 1psql -l 连接数据库 1\c dbname 显示数据库表 1\d 创建一个名为 test 的表 1CREATE TABLE test(id int, text VARCHAR(50)); 插入一条记录 1INSERT INTO test(id, text) VALUES(1, 'sdfsfsfsdfsdfdf'); 查询记录 1SELECT * FROM test WHERE id = 1; 更新记录 1UPDATE test SET text = 'aaaaaaaaaaaaa' WHERE id = 1; 删除指定的记录 1DELETE FROM test WHERE id = 1; 删除表 1DROP TABLE test; 删除数据库 1DROP DATABASE dbname; 或者利用 dropdb 指令，在终端上删除数据库 1dropdb -U user dbname]]></content>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建PHP开发环境]]></title>
    <url>%2F2017%2F02%2F25%2FPHP%E5%B7%A5%E5%8C%A0%E5%8E%86%E9%99%A9%E8%AE%B0-%E5%BC%80%E5%90%AF%E7%AF%87-%E4%B8%80%E3%80%81%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[从本文开始，记录一直以来的 PHP 开发历程， 一方面，自己温故而知新； 另一方面，跟大家一起学习进步。 第一篇文章当然是搭建 PHP 开发环境啦。至于 PHP是什么，以及 PHP 能干什么等等的问题，我这不赘述，请自行 Google。 在 Mac 系统搭建 LAMP开发环境。 一、 启动 Apache mac 系统自带 Apache 服务器;只需要知道如何启动即可。一个方法是通过终端启动。 1sudo apachectl start 此时在浏览器中输入http://localhost，会出现It works！的页面。 另外的方法是： 打开”系统偏好设置”-&gt;”共享”，在”互联网共享”那一项前面打√。 二、运行 PHP1、打开 Apache 的配置文件 1sudo vi httpd.conf 找到 #LoadModule php5_module libexec/apache2/libphp5.so 这一行； 把前面的# 删除；然后保存退出。如图： 2、重启 Apache, 然后 PHP 即可正常使用。 1sudo apachectl restart 3、检验 PHP 是否正常。 1php -v 是否看到 PHP 的版本信息；有的话证明已成功。如图： 4、 关于更多 PHP 命令行，可以自行搜索学习。常用的： 12345php -i #查看 php 的详细信息；跟 phpinfo()效果一致。php -i | grep php.ini #查看 php.ini 所在位置。php -m #查看 php 扩展模块的安装情况 三、安装 MYSQL1、在MYSQL网站上，选择Mac OS X平台，然后选择图中的DMG格式下载下载完后，自行安装。2、修改 MYSQL 的密码；如设置密码为12345 1/usr/local/mysql/bin/mysqladmin -u root password 12345 3、 关于 MYSQL 的 GUI 管理工具；本人推荐 sequel pro ；其他工具自行下载安装。 四、要想进行 PHP 开发，当然还要有编辑器，你可以选择自己喜欢的编辑器进行开发，但都推荐免费开源放工具，以免造成不要的麻烦。Linux 安装 LAMP开发环境 在这里推荐一步一步的进行安装，尤其的初学者，必须自己走一遍才知道如何安装，每个人出现的错误会不一样，在处理错误的过程一定会有收获。不建议，一开始为了省事，去使用LAMP 一键安装脚本 ，当你完全掌握后，才推荐使用这种方法。由于 LINUX 的发行版本较多，这里以Centos7 系统为例子，其他发行版大同小异。 安装 Apache1yum install httpd httpd-devel 启动 Apache1systemctl start httpd.service 测试以下apache是否安装成功，打开浏览器，输入http://localhost， 是否显示apache的主页。 安装MYSQL; mysql在centos7.0版本中被mariadb替代了。1yum isntall mysql mysql-server 安装好了，选择修改mysql默认的root用户的密码，启动mysql服务。 启动 MYSQL1service mysqld start 安装 PHP1yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 若要安装其它 PHP 版本，把56改成其它版本号即可。 安装 php-fpm1yum install php56w-fpm 安装pear// 下载 go-pear 脚本 123456[arthur@arthur Downloads]$ wget http://pear.php.net/go-pear.pharphp// 先切换到root账户，避免指定安装目录的时候没有权限导致安装失败```bash[arthur@arthur Downloads]$ suPassword: // 执行安装 1[root@arthur Downloads]$ php go-pear.phar #####配置pear命令 安装完成后，默认只能使用 安装目录/bin/pear的方式使用命令，为了方便后续直接使用，我们还需要把pear的安装目录加到配置文件中 /etc/profile输入 1export PATH=/opt/pear/bin:$PATH 更新 1source /etc/profile 安装Composer下载composer.phar1curl -sS https://getcomposer.org/installer | php 把composer.phar移动到环境下让其变成可执行1mv composer.phar /usr/local/bin/composer 测试1composer -V 测试 PHP 是否安装成功； 1php -v 终端显示 PHP 的一些版本信息。 安装PHP 对 MYSQL 的支持1yum install php-mysql 基本的开发环境就可以搭建好了。 Windows 系统安装 LAMP 。哦， 我没用过 Windows 系统。个人建议开发还是尽量不要使用 Windows 了。当然非要在 Windows 上做开发的话，我这就不描述如何安装了。总结 开发环境是所有开发的基础，一定要稳扎稳打，静静的自己安装，不要偷懒哦！平时多上网查看其它的文章教程，每个人写的文章不一样。]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>开发环境</tag>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建反向代理，实现远程管理]]></title>
    <url>%2F2017%2F02%2F25%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文记录如何在树莓派上实现反向代理，穿透内网进行远程登录和操作树莓派。本方法也适用于其他 Linux 系统和 mac osx系统，但目录上有所区别。 一、 必备条件1、具有公网 IP 的 vps 或者云主机。 2、一定的 Linux 知识背景。 3、树莓派。😆 二、SSH 反向代理 准备工作。 生成 ssh 密钥.在 pi 上输入以下命令（选用一个类似“&lt;你的名字&gt;@&lt;你的设备&gt;”这样可辨识的主机名，这里我们使用qmj@pi）： 1ssh-keygen -t rsa -C qmj@pi 在 pi 上在输入以下命令。(比如我的 vps 的用户名是qmj@qmjIP) 1ssh-copy-id -i ~/.ssh/id_rsa.pub qmj@qmjIP 3、由于 pi 的默认用户是 raspiberry ，所以要获取 pi 的 root 权限：执行 1sudo passwd root 命令，修改root密码； 然后，编辑/etc/ssh/sshd_config文件，找到PermitRootLogin一行；如果之前执行过 1sudo passwd --unlock root 的话，这里可能会显示“without-passwd”什么的，把这行修改为“PermitRootLoginyes”，保存退出然后重启系统，root账号应该可以直接登录了。 三、开启 ssh 反向代理我们一般的计算机状况 编号 IP 用户名 说明 A 192.168.1.A U_a 目标 计算机，（即树莓派），在局域网中，可以访问 A B B.B.B.B U_b 代理服务器（我们的 vps 或云主机），在外网中，无法访问 A C - U_c 外部的计算机，比如公司的电脑，可以访问B，无法直接访问 A 设计方案：在 A 机器上做到 B 机器的反向代理；在 B 机器上做正向代理本地端口转发 环境需求•每台机器上都需要 SSH 客户端• A、B 两台机器上需要 SSH 服务器端。通常是 openssh-server。在 Ubuntu 上安装过程为 1sudo apt-get install openssl-server 其他系统版本，自行搜索安装。 具体步骤 建立 A 机器到 B 机器的反向代理【A 机器上操作】1ssh -fCNR &lt;port_b1&gt;:localhost:22 u_b@B.B.B.B 2. 为 B 机器上端口，用来与 A 机器上的22端口绑定。 建立 B 机器上的正向代理，用作本地转发。做这一步是因为绑定后的 端口只支持本地访问【B 机器上操作】1ssh -fCNL "*:&lt;port_b2&gt;:localhost:&lt;port_b1&gt;' localhost 4. 为本地转发端口，用以和外网通信，并将数据转发到 ，实现可以从其他机器访问。其中的*表示接受来自任意机器的访问。 现在在 C 机器上可以通过 B 机器 ssh 到 A 机器1ssh -p &lt;port_b2&gt; u_a@B.B.B.B 解决。 关于 SSH 的参数使用说明。SSH 参数解释-f 后台运行-C 允许压缩数据-N 不执行任何命令-R 将端口绑定到远程服务器，反向代理-L 将端口绑定到本地客户端，正向代理 还有就是vps 或云主机要开启自动端口转发。vps上 1vi /etc/ssh/sshd_config 找到GatewayPorts把前面的#去掉 后面改成yes 四、autossh 反向代理在上文中，我们已经能够在C 计算机通过 B 计算机访问 A 计算机，但这个代理是暂时的，会出现代理随时断开或者下次重启树莓派又要重新开启，步骤麻烦。因此，我们把方案优化，升级 ssh 的代理工具，使用 autossh 这个工具。我们先要安装 autossh。在 pi 上操作 1apt install autossh 然后输入命令 1autossh -M 53457 -fNR 5000:localhost:22 mo@42.96.135.22 就这样开启了反向代理，作用跟前面的一致。但，这里当代理连接断开后，会自动重连，不需要担心，突然连不上自己的 pi 了。 但 我们的 pi 重启后，也是要输入上述 sutossh 的命令，为了更加自动化，把autossh 加入 开机启动里12sudo nano /etc/rc.local/bin/su -c '/usr/bin/autossh -M 33300 -fNR 5000:localhost:22 mo@21.15.196.22 这才是完美解决。 autossh 参数解释-M 53457 参数，负责通过5678端口监视连接状态，连接有问题时就会自动重连， 去掉了一个-f参数，因为autossh本身就会在background运行。]]></content>
      <tags>
        <tag>树莓派 raspberrypi</tag>
        <tag>autossh</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[objective-c初学笔记]]></title>
    <url>%2F2017%2F02%2F21%2Fobjective-c%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是2014年在创业时打算开始做 ios 开发的学习笔记，拿过来，做些备忘。主要是 OC的一些基础知识，比较易懂。 1. 在objective-c中使用＃import&lt;&gt;导入系统头文件，＃import””导入用户头文件,＃import可以保证头文件只被包含一次。 2. 基本数据类型总结2.1 基本数据类型分类 1) 整型 int，short int, long int 2) 浮点型 float, double 3) 字符型 char 2.2 数据输出格式： 1) int 输出格式符：%i, %d, %o, %x unsigned int 输出格式符：%u short 输出格式符：%hi, %hd unsigned short int 输出格式符：%hu long int 输出格式符: %li, %ld unsigned long int 输出格式符：%lu 2) float,double 输出格式符：%f, %e, %g long double 输出格式符: %lf 3) char 输出格式符：%c,字符串为%s3. 语句循环语句：for, while, do while, break, continue 分支：if, else, switch4. NSlog()函数：与printf()类似，向控制台输出信息。但它增加了时间戳等一些特性。例：向控制台输出hello world。 NSString *str = @”hello world”; NSLog(@”%@”, str); %@表示输出NSString类型； 双引号的前面的@表示这双引号中的字符串应该作为cocoa的NSString元素来处理。 #### 5. 布尔类型BOOL:值为YES,NO;6. objective-c中的方括号：1) 用于通知某个对象该做什么。 2) 方括号内第一项是对象，其余部分是你需要对象执行的操作。 3) 在objective-c中通知对象执行某种操作，称为发送消息。（也叫调用方法）7. 标识符id:是一种泛型，用于表示任何种类的对象。8. 类声明@interface：例： @interface Circle:NSObject //为Circle类定义接口；NSObject表示是父类。 {//以下是数据成员 ShapeColor fillColor; ShapeRect bounds; } //以下是方法声明 -(void) setFillColor: (ShapeColor) fillColor; //前面的短线表明这是方法声明 //短线后面是方法的返回类型 //接着是方法名 //冒号后面是参数，其中(ShapeColor)是参数类型， fillColor是参数名 -(void) setBounds:(ShapeRect) bounds; -(void) draw; //减号就是普通函数 加号就是静态函数 @end //结束声明#### 9. self，隐藏对象self对应于C中的this。 Self-&gt;fillcolor来访问成员变量。 10. 调用写好的类和类函数：//创建新对象，使用缺省初始化函数 Bank *bankDefault = [[Bank alloc] init]; //调用方法： [bank addAmount: 1]; [bank print]; // 释放对象： [bankDefault free];11. 两个参数的方法：-(void) setTire: (Tire *) tire //声明 atIndex: (int) index; //使用 [car setTire:tire atIndex:2]; objective-c高级特性：12. 继承Objective-c不支持多继承。 Super 关键字：调用该类的父类； 超类：父类的另一种说法。13. 自定义NSLog()输出:在类中添加description方法就可以自定义NSLog()如何输出对象。 @implementation Tire -(NSString *) description { Return (@”I am a tire.”); } Main() { NSLog(@”%@”,tire[0]); }13. Foundation kit:Cocoa是由两部分框架组成的：foundation kit [包括一些基础类]和 application kit.【包括用户接口对象和高级类】 创建字符串： 1） NSString *test; test=[NSString stringWithFormat:@&quot;i&apos;m %d years old!&quot;,23]; 若在声明方法时在方法前面添加了加号，那就表示把这个方法定义为类方法【这个方法属于类对象，而不是类的 实例对象。 NSArray类：可以存放任意类型的对象. 它有两个限制： 1. 它只能存储objective-c的对象，但不能存储C中的基本数据类型，如int , float, enum, struct等。 2.不能存储nil(对象的零值或NULL值)；【因为在创建NSArray时，要在列表结尾添加nil代表列表结束。】 2） 创建NSArray： NSArray *array; array=[NSArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,nil]; NSString, NSMutableString类； NSString是不可变的，即一旦创建完成，就不能通过删除字符或添加字符的方式来改变它； 而NSMutableString是可变的。 NSArray, NSMutableArray类； NSEnumerator枚举； NSEnumerator *enum; enum=[array objectEnumerator]; Id thingie; While(thingie=[enumerator nextObject]){} NSDictionary:字典（关键字及其定义的集合。）【也成为散列表，关联数组】，NSMutableDictionary类； NSNumber:用来包装基本数据类型，如int ,char, float, bool;【将一个基本类型的数据包装成对象叫做装箱。】 NSValue:它可以包装任何类，NSNumber是它的子类。 NSNull: 在cocoa中看到“CF”字样时，就表示它是苹果公司的Core Foundation 框架相关的内容。 NSAutoreleasePool:自动释放内存池。14. 内存管理每个对象都有一个与之关联的引用计数（也叫保留计数） 当使用alloc, new 方法或通过 copy消息（生成接收对象的一个副本）创建一个对象时，对象的引用计数值被设为1； 给对象发retain消息时，增加该值； 发送release消息时，减少该值； 当一个对象的引用计数值变为0时，objective-c会自动向对象发送一条dealloc消息。销毁该对象。 你可以在自己的对象中重写该方法， 使用retainCount消息，可以获取引用计数器的值。 -(id) retain; -(void) release; -(unsigned) retainCount; 自动释放池：autorelease pool; 创建： NSAutoreleasePool *pool; pool=[[NSAutoreleasePool alloc] init]; 销毁： [pool release]; 注意：xcode自动生成的代码，销毁pool池时，使用的是[pool drain],drain方法只是清空释放池，但不销毁pool.所以 在自己编写代码时还是使用 release. 而且，drain只适用于MAC OS 10.4以上的版本，而release适用于所有版本。 只有在向某个对象发送autorelease消息时，该对象才会添加到NSAutoreleasepool中，才会被自动释放。 如：[car autorelease]; 内存管理黄金准则： 只有通过alloc, new和 copy方法创建的对象，才需要程序员负责向该对象发送release或autorelease消息。 而通过其他方法获得的对象，则默认为已经被设置为自动释放，所以不需要程序员做任何操作了。 在objective-c 2.0中有垃圾回收机制， 如果要对某个项目使用垃圾回收： 项目信息--build选项卡--查询&quot;garb&quot;,出现“objective-c Garbage Collection”,将其值设置为“required[-fobjc-gc-only]” 启用垃圾回收后，通常的内存管理命令全都变成了空操作指令，不执行任何操作。 开发iphone软件，不能使用垃圾回收。15.对象初始化 两种创建新对象的方法： [类名 new] [[类名 alloc] init] 这两种方法是等价的，但cocoa的惯例是使用后者。 alloc在为对象分配空间的同时，将这块内存初始化为0； Init方法：初始化实例变量，使对象处于可用状态。[返回类型为id, 返回的值描述了被初始化的对象] 使用new创建新对象时，系统要完成两个步骤： 1. 为对象分配内存，即对象获得一个用来存放其实例变量的内存块； 2. 自动调用init方法，让该对象处于可用状态。16.objective-c 2.0的新特性【只适用于mac os x10.5及以上】 @property :表示声明了对象的属性。这样就不用再写属性的访问器了。 （他有copy, retain, readwrite, readonly等属性） 点表达式17.类别 类别（category）是一种为现有的类添加新方法的方式。 类别的声明： @interface NSString (NumberConvenience) //类名 （类别名） -(NSNumber) lengthAsNumber; //扩充方法声明 @end 使用时使用原来的类名，就可以调用他的所有类别中的方法。 类别的局限性： 1. 不能向类中添加新的实例变量； 2. 在类别中的方法若与类中现有的方法重名，则类中的方法不可用，被类别中的新方法取代。 类别的作用： 1. 将类的实现分散到多个文件或框架中； 2. 创建对私有方法的前向引用； 【Cocoa中没有真正的私有方法，则实现私有方法类似功能的方法为： 先在类别中声明方法；然后到现有类的实现中实现该方法。 这样这个类中的其他方法可以使用该方法，而其他外部的类就不会知道该方法的存在了。】 3. 向对象添加非正式协议。 【创建一个NSObject的类别称为创建一个非正式协议。】 委托delegate是一种对象，另一个类的对象会要求委托对象执行它的某些操作。 受委托对象在某个时间（某个事件触发）时，会自动通知委托对象执行委托方法。 选择器：@selector（）:选择器只是一个方法名称，但它以objective-c运行时使用的特殊方式编码，以快速执行查 询。圆括号中的内容是方法名。 所以Car类的setEngine:方法的选择器是：@selector（setEngine: 受委托对象如何知道其委托对象是否能处理它（受委托对象）发送给它（委托对象）的消息？ ，受委托对象先检查委托对象，询问其是否能响应该选择器。如果能，则向它发送消息。18.协议： 正式协议是一个命名的方法列表。 采用协议意味着必须实现该协议的所有方法。否则，编译器会发出警告。 正式协议就像JAVA中的接口一样。 声明协议： @protocal NSCopying - (id) copywithzone:(NSZone *) zone; //方法列表 @end 采用协议： @interface Car:NSObject &lt;NSCopying,NSCoding&gt; //中括号中是要实现的协议列表 {//实例变量列表} //方法列表 @end]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Object C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 入门必看指南]]></title>
    <url>%2F2017%2F02%2F20%2Fweb-%E5%85%A5%E9%97%A8%E5%BF%85%E7%9C%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[整理本人从零开始学 web 开发的资料，和一些学习心得。 一. 开发环境搭建 wndows下可以使用集成的web服务器，推荐wampserver 下载地址：http://pan.baidu.com/s/1qWA0KRq （1）Wampserver的安装，一路next下去。 （2）过程中出现选择默认浏览器的操作，可以选择取消。 （3）wampserver安装完成后，点击打开。找到www目录，这就是网页文件存放的地方。 （4）关于phpmyadmin的使用，稍后再数据库mysql的部分介绍。 （5）Windows的数据库管理工具还可以使用 navicat 软件。使用在后面介绍。 （6）访问本地网站，在浏览器输入http://localhost 在linux下，以ubuntu系统为例子。（推荐使用ubuntu） (1)安装很简单，打开终端。输入 1sudo apt-get install apache2 mysql-server mysql-client php5 php5-gd php5-mysql (2) 调整默认Web目录权限 1sudo chmod 777 -R /var/www/html (3) Apache 配置 启用 mod_rewrite 模块:终端命令： 1sudo a2enmod rewrite (4) 重启Apache服务器： 1sudo /etc/init.d/apache2 restart (5)数据库管理软件 phpmyadmin 安装 1sudo apt-get install phpmyadmin （6） 安装时要求选择Web server：apache2或lighttpd，选择apache2，设置Mysql数据库密码。然后连接phpmyadmin与apache2，以我的为例：www在/var/www/html，phpmyadmin在/usr/share /phpmyadmin目录，用命令： 1sudo ln -s /usr/share/phpmyadmin /var/www/html 建立连接。 （7）phpmyadmin测试，在浏览器中打开http://localhost/phpmyadmin 更多关于phpmyadmin的用法在数据库部分介绍。 （8）访问本地网站在浏览器输入http://localhost 二. 编辑器的选择与使用 如果有编程的经历，可以使用自己熟悉的编辑器或者IDE 前端开发，可以使用vim. sublime. notepad++. editplus。 php开发，可以使用 上面所说的编辑器。也可以用php的IDE，例如PHPstorm。 各编辑器的使用可以参考网上的一些教程。只要一个原则，适合自己的编辑器才是最好的编辑器。 各编辑器的下载大家自己从网上下载。 三. SVN的使用，下载地址 http://pan.baidu.com/s/1bntqrk7 ，此针对windows系统。 SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS. CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。 更多关于svn的使用教程，参考 http://pan.baidu.com/s/1hq7ZqIw 上面的文档。 svn的好处就是一个团队的协作开发得到更好的控制，而且防止不可抗因素的出现导致源代码丢失。当然还可以使用github。 四. ubuntu系统下SVN的安装与使用 安装svn客户端：12345678apt-get install subversion，然后根据提示一步一步，就完成了svn```php的安装。当然，也可以源码安装svn，下载subversion一个最新版本的源码包，解压之后就可以安装了。 2. 新建一个目录，cd 到新建目录下，将文件checkout到本地目录：```phpsvn checkout svn://192.168.100.249/server ，按提示输入相应的用户名和密码。 3. 可以输入：svn help 来查看svn提供的命令。 往版本库中添加新的文件，例如: svn add *.c (添加当前目录下所有的c文件)。 5. 将改动的文件提交到版本库，例如： 1svn commit -m “add test file for my test“ test.c 。 删除文件，例如： 1svn delete svn://192.168.100.249/server/common/test.c -m “delete test file” 。 如果哪个命令不会使用可以通过输入：svn help 命令 的形式来查看帮助信息，例如： 123svn help chechout 输出信息如下： checkout (co): Check out a working copy from a repository. usage: checkout URL[@REV]... [PATH] 更多关于ubuntu的svn使用，参考 http://pan.baidu.com/s/1mgxbHGW 五. 编程过程 不管哪种编程都应该学会当遇到困难时，可先百度. 谷歌. 知网. 知乎；还可以加入一些对应的Q群，必要时询问Q群的大神；确实不行就跟团队成员交流。网上搜索，我十分推荐去谷歌搜索问题的解决办法，此处分享一个能上谷歌的番茄神器。 Hoststool。此处贴出windows的版本 http://pan.baidu.com/s/1jGtccf0 使用方法按照上面的提示操作。 关于其他操作系统的可以去官网下载，地址： https://hosts.huhamhire.com/ 这里也给出集成了翻墙软件的谷歌浏览器， 地址 链接：http://pan.baidu.com/s/1c05zAqW 密码：n3j9 由于web开发的运行环境就是平时使用的浏览器。至于使用哪个浏览器，在这我建议 谷歌浏览器 chrome ，还有火狐浏览器。若是前端开发，需要测试网站兼容性的，可以使用其他浏览器查看，但debug的功能最好在chrome或者火狐浏览器完成。 谷歌浏览器和火狐浏览器的前端debug使用方法，可以再网上搜索，在这里不再叙述。 六. 开发建议，所有语言教程，建议查看官方开发手册。 关于html，css和JavaScript的入门和使用教程，推荐去W3CSchool这个网站学习 ，网址http://www.w3cschool.cc/ 也可以下载离线版本 http://pan.baidu.com/s/1kTj6DwF 为了能快速开发，在开发过程中推荐使用前端框架，避免不必要的代码重复书写工作，加快项目进度。现在大多数网站采用bootstrap 这个前端框架 ，网址 http://www.bootcss.com/ 至于这是什么样的框架和使用教程可以参考官网，不再叙述。 还有AmazeUI 这个框架，使用教程参考官网 ，网址：http://amazeui.org/ *注：至于实际开发采用哪一个，看实际需要。 JavaScript的使用可以参考w3cschool 网站的教程。 网址：http://www.w3cschool.cc/ ，前端开发者，要熟悉使用jquery，还有封装项目中使用到的JavaScript 类库。 PHP教程，同样可以在w3cschool 网站找到。推荐查看php官网的手册，离线版本下载 http://pan.baidu.com/s/1hhhaY ，这里还有php的基础教程，仅供参考http://pan.baidu.com/s/1eQy9SMu PHP框架，比如，国内的thinkphp 国产中较好的之一，网址：http://www.thinkphp.cn/ 国外的laravel ，最受欢迎的，网址：http://laravel.com/ 。选择哪一个框架要结合项目开发需求和自己的开发经验。 学习框架的最好方法就是不断看手册和逛官方社区 mysql教程，同样可以在w3cschool 网站找到。推荐查看mysql官网的手册，离线版本下载 http://pan.baidu.com/s/1pJqPW1P （1） 无论在windows还是ubuntu中，都可以使用数据库图形管理工具 phpmyadmin 。phpmyadmin的使用教程 http://pan.baidu.com/s/10JWtC （2） 在windows中，我们还可以使用navicat for mysql 这个数据库图形管理工具 ，下载地址http://pan.baidu.com/s/1m6N1c 使用方法跟phpmyadmin差不多，但功能会多很多，自行探讨。 （3） 数据库的开发可能需要用到建模工具，此处给出一个叫powerdesigner 的软件，下载地址：http://pan.baidu.com/s/1o6MGgXk 使用教程自行查询。 Git 的使用指南。 http://rogerdudler.github.io/git-guide/index.zh.html 最开始我是使用 SVN 进行代码托管，后来改用 Git.两者的优缺点在这就不描述，看个人喜好。 七. 总结 不管做什么编程，都应该以实践为主，不要一直捧着书本或者一直看别人的视频，自己看懂了却不去动手敲代码。 以上的教程仅作参考，软件涉及到32位和64位的问题时，自行解决。 web编程中，不管是专注前端还是后台，都应该去了解自己未负责的部分，互相渗透。 若发现错漏之处，欢迎提出。 希望大家技术猛进！]]></content>
      <tags>
        <tag>web</tag>
        <tag>入门指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下 搭建Cordova+ionic+AngularJs开发环境]]></title>
    <url>%2F2017%2F02%2F20%2Fmac%E4%B8%8B-%E6%90%AD%E5%BB%BACordova-ionic-AngularJs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简单介绍如何在 mac 下安装 ionic 开发环境，以及创建项目 一、下载安装node.js 下载node.js for mac ![](https://ooo.0o0.ooo/2017/02/20/58aaedbabb0c2.png)​​​​​ 一路点击 next 二、安装cordova和ionicsudo npm install -g cordova ionic 三、创建项目ionic start ionApp blank 四、打包1$ ionic platform add ios]]></content>
      <tags>
        <tag>mac系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3安装 Docker记录]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE3%E5%AE%89%E8%A3%85-Docker%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[今天有空就查询一下在树莓派如何安装 docker，边安装边记录了一下。 树莓派3下安装 docker 记录 关于 docker 的介绍请自行查询 https://www.docker.com/ 直接在树莓派3运行命令 很好, 提示我已经安装了最新的版本, 那就运行一下吧: 奇怪了, 说是找不到命令, 那就看看安装到哪里去了: 12root@raspberrypi:~# whereis dockerdocker: 没有找到关于 docker 的可执行文件, 而用 whereis 命令查找 git 的输出如下: oot@raspberrypi:~# whereis gitgit: /usr/bin/git /usr/share/man/man1/git.1.gz那么用 find 搜索一下: 123root@raspberrypi:~# find / -name docker/usr/share/menu/docker/usr/share/doc/docker 看起来都不是一个独立的软件包的样子, 那么我们用 apt-cache search 命令看看是否还有其他以 docker 为名的软件，发现 docker 跟 raspbian 系统下的一个系统托盘应用重名了, 我们要找的容器 docker 是 docker.io, 那么试着安装一下: 顺利安装完毕, 测试是否成功: 123root@raspberrypi:~# docker --versionDocker version 1.3.3, build d344625 Good, 现在已经成功地在 raspi3 系统上安装了一个 docker, 之后就可以在 docker 进行操作了. 启动我们的 docker 守护进程: 123456root@raspberrypi:~# docker -d2017/02/18 14:22:25 docker daemon: 1.3.3 d344625; execdriver: native; graphdriver:[143dcfc4] +job serveapi(unix:///var/run/docker.sock)2017/02/18 14:22:25 pid file found, ensure docker is not running or delete /var/run/docker.pid]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>树莓派 raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2017%2F02%2F17%2Fhexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[备忘常用 hexo 的命令。 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） ###其他命令 123$ hexo init $ hexo new "articleName"$ hexo new page "pageName" 组合命令12$ hexo d -g #生成部署$ hexo s -g #生成预览]]></content>
      <tags>
        <tag>hexo命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinkphp微信支付开发坑]]></title>
    <url>%2F2017%2F01%2F23%2FThinkphp%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E5%9D%91%2F</url>
    <content type="text"><![CDATA[介绍如何在ThinkPHP中引入微信支付，并成功记录附加信息。 本文针对的是 微信支付V3 一、准备工作首先得有一个已认证的服务号。还要去申请开通微信支付（当然如果只是想玩玩可以申请测试公众号）。记录各种 key 和 secret。配置好 JS SDK 的域名、授权域名（OAuth2）、支付测试目录、支付目录，如果是有第三方托管的还要对接服务器。具体自行 搜索。 二、库引入下载官方的 DEMO ，整合到自己的项目中。我用的是 thinkphp 框架，一般把微信支付 SDK放到Vendor中。（也可以放项目根目录）。 三、微信支付发起业务逻辑挺简单的，后台引入 SDK和配置文件。统一下单等等。这些 DEMO 里都有。不累赘了。 四、支付那些坑有三种方式查询支付状态，1、异步通知：每次支付成功后会有通知返回，只有成功处理通知，微信才会停止发送，但不确保一定成功回调。这里的坑就是接受通知的地址一定要直接访问到。举个例子：开发过程中，我尝试把处理通知的文件放在 thinkphp 的控制器中，发现就是收不到通知，后来放到根目录，就行了。我不知道是不是一定要放在根目录，但我知道放在根目录一定可以。但如果开发过程需要带上其他参数，比如我这次的流程是先根据输入查询用户数据，接着微信支付，支付完需要加上之前查询到参数，一起发给充值平台。在一开始我一直想用 SESSION 和数据库存储充值参数，但由于支付完成后是一个异步操作，用 SESSION 会造成 SESSION 无效；用数据库存储会有很大开销或者有数据原子性的问题出现，所以就要好好研究统一下单时的那些参数，你会发现一个 attach 这个参数，先把参数发给微信，微信在支付通知返回时一起带回来，就避免上述的问题。2、前端 JS 返回：在每次支付时或支付完成后，前端会有一个回调，来查询支付状态。但有一个问题就是，每次支付完成后，用户必须点击右上角“完成”按钮，才会回调，这样的体验很不好，这个只能作为非必须功能或者返回首页之类。3、主动查询：用订单号无主动查询订单状态，这个应用场景不适合连贯性很强的支付操作过程。 五、总结1、多看博文和社区的讨论；2、每一步都要有日志，方便查 BUG3、做好数据过滤，支付通知可能在成功处理后还是会发过来，那么就要做好忽略，避免加大开销。4、安全方面，有表单的地方一定要做好数据过滤；防止 SQL 注入和 XSS 攻击等。5、涉及到真金白银的程序一定要多做测试，毕竟上线后如果没支付就交易成功或者支付完又没交易；就 呵呵了。 我用的 微信 SDK ，http://pan.baidu.com/s/1c1GlrtY 密码：44sp]]></content>
      <tags>
        <tag>微信</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu64位安装32位依赖库，并安装njit-client]]></title>
    <url>%2F2017%2F01%2F23%2Fubuntu64%E4%BD%8D%E5%AE%89%E8%A3%8532%E4%BD%8D%E4%BE%9D%E8%B5%96%E5%BA%93%EF%BC%8C%E5%B9%B6%E5%AE%89%E8%A3%85njit-client%2F</url>
    <content type="text"><![CDATA[自从Ubuntu12.04之后，就移除了32位的库，当时为了安装校园网的客户端，就不得不安装32位的库。 ###这是很早之前的文章了，当时为了破解学校的网络客户端。####方法一:12345sudo -icd /etc/apt/sources.list.decho "deb http://archive.ubuntu.com/ubuntu/ raring main restricted universe multiverse" &gt;ia32-libs-raring.listapt-get updateapt-get install ia32-libs PS:这种方法肯定能安装上ia32-libs，但由于添加的是13.04的源，所以有没有混淆暂时不清楚，网上也有很多用新立德软件包管理器这样做；够狠，你就这么干。也可以这么安装了ia32-libs后，把/etc/apt/sources.list.d目录下的ia32-libs-raring.list删掉，然后再sudo apt-get update ####方法二:切换至中科大的源 http://uestc.edu.cn 然后 12 apt-get updateapt-get install ia32-libs 如果终端出现: 1234567891011121314错误 http://archive.ubuntu.com/ubuntu/ raring/main libgd2-xpm i386 2.0.36~rc1~dfsg-6.1ubuntu1 * 404 Not Found [IP: 91.189.91.23 80] *错误 http://archive.ubuntu.com/ubuntu/ raring/main libgphoto2-port0 i386 2.4.14-2* 404 Not Found [IP: 91.189.91.23 80] *错误 http://archive.ubuntu.com/ubuntu/ raring/main libgphoto2-2 i386 2.4.14-2* 404 Not Found [IP: 91.189.91.23 80] *---------------------------------------E: 无法下载 http://archive.ubuntu.com/ubuntu/pool/main/libg/libgd2/libgd2-xpm_2.0.36~rc1~dfsg-6.1ubuntu1_i386.deb 404 Not Found [IP:* 91.189.91.23 80] *------E: 无法下载 http://archive.ubuntu.com/ubuntu/pool/main/libg/libgphoto2/libgphoto2-port0_2.4.14-2_i386.deb 404 Not Found [IP: 91.189.91.23 80]*E: 无法下载 http://archive.ubuntu.com/ubuntu/pool/main/libg/libgphoto2/libgphoto2-2_2.4.14-2_i386.deb 404 Not Found [IP: 91.189.91.23 80] *E: 有几个软件包无法下载，您可以运行 apt-get update 或者加上 --fix-missing 的选项再试试？* 自己去网上搜索这三个包,然后安装.或者使用以下网址: https://packages.debian.org/wheezy/i386/libgphoto2-port0/download https://packages.debian.org/wheezy/i386/libgphoto2-2/download https://launchpad.net/ubuntu/raring/i386/libgd2-xpm/2.0.36~rc1~dfsg-6.1ubuntu1 安装后再执行 1apt-get install ia32-libs 没有意外应该装上了. ps:附上缺失的三个包的百度云。。。链接 http://pan.baidu.com/s/1kTJz8k3 原文地址：http://blog.csdn.net/moxxun/article/details/45129833]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云和又拍云的比较]]></title>
    <url>%2F2017%2F01%2F22%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[又拍云：老牌静态存储服务商，自带有CDN。存储空间可以弹性增加。费用计算公式(空间和流量)，请求次数是免费。可免费试用7天。开源的程序(DZ,PW,WP)都有插件，也可以直接使用FTP，对于技术上要求不是太高就可以使用。七牛：10GB永久免费存储空间,每月10GB下载流量,10万次Put 又拍云：老牌静态存储服务商，自带有CDN。存储空间可以弹性增加。费用计算公式(空间和流量)，请求次数是免费。可免费试用7天。开源的程序(DZ,PW,WP)都有插件，也可以直接使用FTP，对于技术上要求不是太高就可以使用。 七牛：10GB永久免费存储空间,每月10GB下载流量,10万次Put请求,100万次Get请求，对于新用户来说，非常友好。价格方面，比又拍云贵。技术使用方面，开源API对于每种语言都有，但对开源程序，似乎没有官方的插件。 文件管理方式 又拍云：FTP、专用软件七牛云：网页、专用软件 免费方式 又拍云：加入网站联盟，在底部加上LOGO和链接 （当时我注册又拍时不需要身份拍照，不知道现在如何） 七牛云：通过身份认证；对于新用户，七牛云存储免费赠送10G 的使用空间+10G/月的流量 收费方式 七牛：七牛是按“存储+流量+访问次数”收费 又拍云：又拍云仅按“存储+流量”收费，更实惠合理一些，开发文档 七牛:文档易读，参数详细，社区资源丰富，开发工具较多。 又拍云： 文档很详细，但有点乱，资源也都，有案例下载。 ###不足之处 ####又拍云： 1.删除空间之前必须删除所有文件和文件夹，FTP删起来非常麻烦，专用软件删起来很快，但依然是要等几百个文件自动一个个删除。2.图片和文件空间分离，图片空间不可上传非图片格式，文件空间无法使用缩略图。（不过技术人员表示，将会进行合并！） ####七牛云： 1.绑定域名、设置防盗链时需要账户余额至少10元，说好的免费服务强行充值一波也是很醉，尽管10块很少但是……2.空间内无法创建文件夹！所有文件丢在一起，原本文件夹里的文件同步到七牛以后，会把路径变成文件名。看到空间里数不完的usr/upload/2015/01/xxx.png，那种卧槽程度简直突破天际。友情提示，这种强行改文件结构的方式会影响你的数据迁出，以后迁移起来很麻烦。（可能需要Bulk Rename Utility之类的软件进行批量重命名并移动至对应文件夹）3.专用软件十分难用，比又拍的更难用。 *本文只代表个人观点]]></content>
      <tags>
        <tag>七牛云</tag>
        <tag>又拍云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC环境下用Clover制作原版安装U盘]]></title>
    <url>%2F2016%2F12%2F22%2FMAC%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%94%A8Clover%E5%88%B6%E4%BD%9C%E5%8E%9F%E7%89%88%E5%AE%89%E8%A3%85U%E7%9B%98%2F</url>
    <content type="text"><![CDATA[本文介绍如何制作黑苹果的U盘镜像 ###一、模板电脑的硬件概览 ###二、准备工作1、mac 系统环境，白苹果、黑屏或虚拟机都行。2、UniBeast 工具（到https://www.tonymacx86.com上下载）3、 MultiBeast 工具(官网 http://www.multibeast.com/) 4、 mac 系统安装镜像。5、8G以上的 U盘。 ###三、制作过程1、注册 App ID，登录 App Store，搜索macOS Sierra ，下载系统安装装包，或者到网上下载 DMG 镜像，解压出安装包。（两者基本没什么区别）。 2、系统下载完成后，把系统安装包复制到Application(应用程序)目录下（从 App Store 下载的跳过此步）。 3、把系统的语言设置成英语，UniBeast 工具只支持英语环境。点击电脑左上角的苹果标志=》选择“系统偏好设置”=》选择“语言和地区”=》选中“英语”网上拉，如图： 然后注销用户，重新登录，即可把系统语言更改为英语。4、格式化 U盘（1）插入 U盘，打开“磁盘工具”，选中目标 U盘（2） 点击 Erase 按钮，命名 USB 的名称（稍后可以重命名），格式化的格式选择 OS X Extended (Journaled) ，分区选择 GUID Partition Map（3）点击 Erase ，格式化完成后退出。 5、U盘制作（1）打开 UniBeast 工具，点击 Continue, Continue, Continue, Continue, Agree（2）在目标选择处，选择 USB ，然后选择 Continue 。（3）在选择安装系统处，选择 Sierra 然后点击 Continue 。（4） 在启动项选择界面选择 UEFI Boot Mode（电脑主板支持 EFI） 或者Legacy Boot Mode.https://app.yinxiang.com/shard/s43/res/8b3d355f-10a6-4059-b1d4-8dc986d7d913（5）（可选）在显卡配置界面选择你需要的配置，然后点击 Continue（6）验证安装选项，然后点击 Continue，输入系统密码，点击 Install。https://app.yinxiang.com/shard/s43/res/7b1d3211-df84-485d-b777-3b4307c048a2（7）UniBeast 开始制作，整个过程需要花费一定的时间。慢慢等待吧。https://app.yinxiang.com/shard/s43/res/77124551-59bc-4cdf-86e3-4ec30fc04c63四、主板设置Disable Secure BootDisable VT for Direct I/OSet Auto OS Recovery Threshold to OFFSet SATA Operation to AHCI or DisabledOptional: Disable ComputraceOptional: Enable Unobtrusive ModeOptional: Enable USB PowerShareOptional: Set Fn Lock Options to Lock Mode Enable/Seconda]]></content>
      <tags>
        <tag>MAC OSX86</tag>
        <tag>Clover</tag>
        <tag>U盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[editormd 的使用介绍]]></title>
    <url>%2F2016%2F11%2F20%2Feditormd%2F</url>
    <content type="text"><![CDATA[主要介绍开源markdown编辑器editor.md的使用方法 Editor.md 目录 (Table of Contents) [TOCM] [TOC] Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Heading 1 link Heading linkHeading 2 link Heading linkHeading 3 link Heading linkHeading 4 link Heading link Heading link Heading linkHeading 5 link Heading linkHeading 6 link Heading link标题（用底线的形式）Heading (underline)This is an H1This is an H2字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt;预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell |JS代码 123456789101112131415161718192021222324252627282930313233343536function test() &#123; console.log("Hello world!");&#125; (function()&#123; var box = function() &#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str) &#123; alert("add", str); return this; &#125;, remove : function(str) &#123; alert("remove", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add("jQuery").remove("jQuery"); HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest="utf-8" /&gt; &lt;meta name="keywords" content="Editor.md, Markdown, Editor" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type="text/css"&gt; body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="text-xxl"&gt;Hello world!&lt;/h1&gt; &lt;p class="text-green"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 ImagesImage: Follow your heart. 图为：厦门白城沙滩 图片加链接 (Image + Link)： 图为：李健首张专辑《似水流年》封面 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\sqrt{3x-1}+(1+x)^2)$$ $$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$ 多行公式： 12345\displaystyle\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2\leq\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right) 123456789\displaystyle \frac&#123;1&#125;&#123; \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123; \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123; 1+\frac&#123;e^&#123;-6\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125; 123f(x) = \int_&#123;-\infty&#125;^\infty \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125; \,d\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says Hello Note right of China: China thinks\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! End]]></content>
      <tags>
        <tag>editor.md</tag>
        <tag>markdown</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
